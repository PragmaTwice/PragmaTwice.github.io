<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Evolution of Apache Kvrocks: Search, Vector and Beyond (CoCAsia 2025)</title>
      <link href="/kvrocks-cocasia25/"/>
      <url>/kvrocks-cocasia25/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Since graduating from the ASF Incubator, Apache Kvrocks has madesignificant progress. The project has attracted an increasing number ofcontributors and continues to evolve with new features.</p><p>Notably, we have introduced a Search module that supports complexqueries and secondary indexing, with compatibility for both RediSearchquery and SQL syntax.</p><p>Building on this foundation, Kvrocks has expanded into new frontiersby integrating cutting-edge features such as vector search, making it amore versatile and powerful data store for modern applications.</p><h2 id="slides">Slides</h2><p>The slides in PDF is available below.</p><embed src="/images/kvrocks-cocasia25/Kvrocks.pdf" width="100%" height="500" type="application/pdf">]]></content>
      
      
      
        <tags>
            
            <tag> kvrocks </tag>
            
            <tag> kvrocks search </tag>
            
            <tag> vector search </tag>
            
            <tag> query engine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KQIR: a query engine for Apache Kvrocks that supports both SQL and RediSearch queries</title>
      <link href="/kqir-query-engine/"/>
      <url>/kqir-query-engine/</url>
      
        <content type="html"><![CDATA[<p><em>repost from <ahref="https://kvrocks.apache.org/blog/kqir-query-engine">https://kvrocks.apache.org/blog/kqir-query-engine</a></em></p><h2 id="intro">Intro</h2><p>TL;DR:</p><figure><img src="/images/kqir-query-engine/demo.png" alt="demo" /><figcaption aria-hidden="true">demo</figcaption></figure><p>Pretty cool, right? Let's dive in!</p><p>(The full example is provided in <a href="#try-it">the finalsection</a>.)</p><!--truncate--><h3 id="apache-kvrocks">Apache Kvrocks</h3><p><a href="https://kvrocks.apache.org/">Apache Kvrocks</a> is a <ahref="https://redis.io/">Redis</a>-compatible database built on <ahref="https://rocksdb.org/">RocksDB</a>.</p><p>It supports <ahref="https://redis.io/docs/latest/develop/reference/protocol-spec/">theRESP protocol</a> (version 2 and 3) and <ahref="https://kvrocks.apache.org/docs/supported-commands">a wide rangeof Redis commands</a>, encompassing core data structures like Strings,Sets, Hashes, Sorted Sets, Stream, GEO, as well as Lua Scripts,Transactions, <ahref="https://redis.io/docs/latest/develop/interact/programmability/functions-intro/">Functions</a>and even <ahref="https://redis.io/docs/latest/develop/data-types/probabilistic/bloom-filter/">BloomFilter</a>,<a href="https://redis.io/docs/latest/develop/data-types/json/">JSON</a>from the Redis Stack.</p><p>Unlike Redis which stores data in memory, Kvrocks persists data ondisk for improved storage capabilities without being constrained bymachine memory limit.</p><h3 id="the-capability-to-query">The capability to query</h3><p>In recent years, NoSQL databases have become more popular thantraditional databases because they perform better, scale easily, and aremore flexible for different industries.</p><p>However, many users are unwilling to abandon the essential featuresof SQL databases just for performance reasons. These include ACIDtransactions, expressive query capabilities inherent in SQL, as well asoptimization and abstraction possibilities offered by structured dataand relational algebra. Consequently, a new category of databases knownas NewSQL has emerged gradually.</p><p>Kvrocks is a NoSQL database. While not classified as NewSQL, Kvrocksaims to strike a balance between NoSQL and NewSQL paradigms: It aims tomaintain the high performance of NoSQL while also implementingtransaction guarantees and supporting more complex queries.</p><h3 id="redisearch">RediSearch?</h3><p><a href="https://github.com/RediSearch/RediSearch">RediSearch</a> isa Redis module that enhances Redis with query, secondary indexing, andfull-text search functionalities. While <ahref="https://redis.io/docs/latest/operate/oss_and_stack/stack-with-enterprise/search/commands/">itsRedis commands</a> begin with <code>FT.</code> (i.e. full text), it goesbeyond just full-text search.</p><p>In fact, it is Redis moving closer to SQL databases: RediSearchenables users to create structured schemas on existing Redis JSON orHASH data for index building. Its schema supports <ahref="https://redis.io/docs/latest/develop/interact/search-and-query/basic-constructs/field-and-type-options/">variousfield types</a> such as numeric, tag, geo, text, and vector - the lattertwo are utilized for full-text and vector searches. Instead of SQLsupport, RediSearch provides <ahref="https://redis.io/docs/latest/develop/interact/search-and-query/advanced-concepts/query_syntax/">aunique query syntax</a> known as the RediSearch query language.</p><p>RediSearch finds applications in various fields. One recentapplication involves utilizing its vector search feature to developretrieval-augmented generation (RAG). For instance, <ahref="https://www.langchain.com/">LangChain</a> utilizes Redis as one ofits vector database. If Kvrocks can be compatible with RediSearch, itcould benefit from these ecosystem from RediSearch.</p><h3 id="sql">SQL?</h3><p>RediSearch uses a unique syntax for queries, but there are someissues to consider:</p><p>Firstly, RediSearch's schema (a.k.a. index, created with<code>FT.CREATE</code>) can be regarded as a table in an SQL database.Its query syntax also aligns semantically with SQL queries. Given thissimilarity, supporting SQL should not increase significant challenges;why not include SQL support as well?</p><p>Secondly, SQL enjoys broader usage and is familiar to moreindividuals. It is simpler to learn at the syntax level. Whiledevelopers may need time to understand RediSearch query syntax, adaptingto a new SQL database often requires less effort. Furthermore, SQLoffers robust support for various query features, enhanced expressivecapabilities (like JOINs, subqueries, aggregations).</p><p>Finally, RediSearch query syntax suffers from some historicaldesigns. For example, the operator precedence of AND and OR (representedby space and <code>|</code> operator in RediSearch queries) <ahref="https://redis.io/docs/latest/develop/interact/search-and-query/advanced-concepts/query_syntax/#basic-syntax">variesacross different dialect versions</a> (dialect 1 vs. dialect 2). Thistribal knowledge might lead users to prefer established querylanguages.</p><p>To sum up, we believe that supporting SQL as a querying languagewould be a good decision.</p><h2 id="how-we-support-both">How we support both?</h2><figure><img src="/images/kqir-query-engine/KQIR.png" alt="KQIR" /><figcaption aria-hidden="true">KQIR</figcaption></figure><p>To introduce SQL capability to Kvrocks, we need to design a robustarchitecture with scalability, maintainability, and strong queryplanning and optimization features.</p><p>We plan to accomplish this through <ahref="https://github.com/apache/kvrocks/tree/unstable/src/search">KQIR</a>.In the context of Kvrocks, KQIR stands for both: 1. The complete queryengine, covering frontend language parsing, query optimization andexecution, etc. 2. An intermediate language (IR) that traverses theentire query engine.</p><h3 id="kqir-a-multiple-level-ir">KQIR: a multiple-level IR</h3><p>To support both SQL and RediSearch queries, an intermediate language(IR) is necessary to handle them consistently in subsequent processeswithout concern for the user's input language.</p><p>We have developed parsers for a subset of MySQL syntax and RediSearchqueries, converting the resulting syntax tree into KQIR.</p><p>And KQIR is a multi-level IR that can represent query structures atvarious levels during optimization. The initial transformation from thesyntax tree results in Syntactical IR, a high-level representation ofcertain syntactic expressions. As it undergoes processing by an IRoptimizer, KQIR evolves into Planning IR, a low-level representationused to express query execution plans within the query engine.</p><p>Additionally, we will conduct semantic checks on the IR beforeoptimization to ensure that the query is semantically correct. Thisincludes verifying that it does not include any undefined schemas orfields and uses the appropriate field types.</p><h3 id="ir-optimizer">IR Optimizer</h3><p>The KQIR optimizer consists of multiple passes, <ahref="https://llvm.org/docs/Passes.html">a concept borrowed fromLLVM</a>. Each pass takes IR as input, conducts analysis andmodifications, and generates a new IR.</p><p>Currently, the optimizer's passes are categorized into three maingroups: - expression passes for optimizing logical expressions like<code>AND</code>, <code>OR</code>, <code>NOT</code> operators; - numericpasses for optimizing numerical comparisons with an interval analysis(i.e. analyze the mathematical properties of numerical comparisons interms of intervals) to enhance query optimization by eliminatingunnecessary comparisons or improving comparison expressions; - planningpasses for converting syntactical IR to planning IR and enhancing queryplans through a cost model that selects optimal indexes and removesunnecessary sortings.</p><p>Pass execution order is controlled by the pass manager. A pass mayrun multiple times at different stages to simplify individual passes bycombining them.</p><h3 id="plan-executor">Plan Executor</h3><p>The KQIR plan executor is built on the Volcano model.</p><p>Once the IR optimizer finishes all optimizations, the resulting IRbecomes a planning IR. This will then be passed to the plan executor tocreate execution logic based on certain context corresponding to theplan operator.</p><p>Subsequently, Kvrocks retrieves query results through iterativeexecution.</p><h3 id="on-disk-indexing">On-disk indexing</h3><p>Unlike Redis, which stores index data in memory, Kvrocks requires theconstruction of indexes on the disk. This means that for any field type(e.g. tag, numeric), we need an encoding to reduce such index toRocksDB's key-values.</p><p>Furthermore, we incrementally create indexes before and after JSON orHASH commands getting executed to guarantee that query results are inreal-time.</p><h2 id="current-status">Current status</h2><p>The KQIR functionality is currently available on the<code>unstable</code> branch, supporting commands like<code>FT.CREATE</code>, <code>FT.SEARCH</code>, and<code>FT.SEARCHSQL</code> (an extension for running SQL queries) toencourage user to test.</p><p>However, as KQIR is still in early development, compatibility cannotbe guaranteed and many features remain incomplete. Thus the upcomingrelease (version 2.9.0) will not include any KQIR component.</p><h3 id="supported-field-types">Supported field types</h3><p>Currently, we only support two field types: tag and numeric.</p><p>Tag fields label each data record with multiple tags for filtering inqueries. And numeric fields hold numerical data within double-precisionfloating-point ranges. They allow sorting and filtering by specificnumerical ranges.</p><p>In the future, we plan to expand support to include vector search andfull-text search capabilities alongside other field types.</p><h3 id="transaction-guarantees">Transaction guarantees</h3><p>Currently, the transaction guarantee of KQIR is weak, which may leadto unexpected issues during use.</p><p><a href="https://github.com/apache/kvrocks/issues/2331">Anotherproject in the Kvrocks community</a> aims to enhance Kvrocks'transaction support by establishing a structured framework. We willleverage these efforts to uphold the ACID properties of KQIR and releasean official version incorporating KQIR after that.</p><h3 id="limitation-on-ir-optimizer">Limitation on IR optimizer</h3><p>Currently, KQIR does not use the cost model when optimizing recordsorting. Instead, it relies on specialized logic. This could be an areafor improvement soon.</p><p>Furthermore, KQIR does not currently utilize optimizations based onruntime statistics. Our future focus will be on integrating runtimestatistics into the cost model for more precise index selection.</p><h3 id="relationship-with-other-features">Relationship with otherfeatures</h3><p>KQIR integrates well with the <ahref="https://kvrocks.apache.org/docs/namespace">namespace</a> feature.Any index created is restricted to the current namespace and cannot beaccessed in other namespaces, aligning with how other data is accessedwithin the namespace.</p><p>Currently, KQIR cannot be enabled in the <ahref="https://kvrocks.apache.org/docs/cluster">cluster mode</a>. Clustermode support may not be implemented in the short term, but we encourageanyone to submit discussions, design proposals, or suggestions.</p><h3 id="compliance">Compliance</h3><p>While KQIR is designed to be compatible with RediSearch at theinterface level, it does not include any code from RediSearch. Aspreviously mentioned, KQIR features a completely new framework, and itsquery architecture (including parsing, optimization, execution) isindependent of RediSearch.</p><p>This distinction is important due to the proprietary license underwhich RediSearch is released.</p><h3 id="high-experimental">High experimental!</h3><p>The current implementation of KQIR is in its early experimentalstage. We advise users to consider carefully when using KQIRfunctionalities in a production environment, as we do not guaranteecompatibility, and there may be unexpected errors.</p><h2 id="future-outlook">Future outlook</h2><p>KQIR is currently in development, and all mentioned aspects willcontinue to evolve. If you're interested, please stay updated on theprogress.</p><p>Developers keen on KQIR are encouraged to get involved in thedevelopment process and join the Apache Kvrocks community.</p><p>Note that our community consists entirely of volunteers. As an ASFcommunity, we strive to offer an open, inclusive, and vendor-neutralenvironment.</p><h3 id="vector-search">Vector search</h3><p>The design and implementation of vector search support are currentlyunderway, which is very exciting.</p><p>In the Kvrocks community, some members have raised discussions and <ahref="https://github.com/apache/kvrocks/discussions/2316">proposed anencoding design</a> for implementing vector search on KQIR.</p><p>As per the plan, we will initially implement an on-disk HNSW indexand introduce the vector field type.</p><h3 id="full-text-search">Full-text search</h3><p>There is currently no design proposal for full-text search.</p><p>However, community members are exploring the potential ofincorporating full-text indexing in KQIR via <ahref="https://clucene.sourceforge.net/">CLucene</a> or <ahref="https://github.com/pisa-engine/pisa">PISA</a>.</p><p>We encourage anyone interested to share their ideas or suggestionsand get involved in the development and implementation.</p><h3 id="more-sql-features">More SQL features</h3><p>In the future, we aim to progressively broaden our support for SQLfeatures, potentially encompassing subqueries (including common tableexpressions), JOIN operations, aggregation functions, and otherfunctionalities.</p><p>Our primary focus will remain on transaction processing rather thananalytical tasks.</p><h2 id="try-it">Try it!</h2><p>First, we can easily set up a Kvrocks instance via Docker images. Youalso have the choice to manually build executable from the source codein the 'unstable' branch.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 6666:6666 apache/kvrocks:nightly --log-dir stdout</span><br></pre></td></tr></table></figure><p>Then, we can connect to kvrocks locally using <code>redis-cli</code>,and create an index named <code>testidx</code> consisting a tag field<code>a</code> and numeric field <code>b</code> with the followingcommand: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.CREATE testidx ON JSON PREFIX 1 &#x27;test:&#x27; SCHEMA a TAG b NUMERIC</span><br></pre></td></tr></table></figure></p><p>Next, we can add some new data using Redis JSON commands: (Note thatit is also possible to add data before running <code>FT.CREATE</code>.)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSON.SET test:k1 $ &#x27;&#123;&quot;a&quot;: &quot;x,y&quot;, &quot;b&quot;: 11&#125;&#x27;</span><br><span class="line">JSON.SET test:k2 $ &#x27;&#123;&quot;a&quot;: &quot;y,z&quot;, &quot;b&quot;: 22&#125;&#x27;</span><br><span class="line">JSON.SET test:k3 $ &#x27;&#123;&quot;a&quot;: &quot;x,z&quot;, &quot;b&quot;: 33&#125;&#x27;</span><br></pre></td></tr></table></figure></p><p>Finally, we can execute some SQL queries to get the desired results:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.SEARCHSQL &#x27;select * from testidx where a hastag &quot;z&quot; and b &lt; 30&#x27;</span><br></pre></td></tr></table></figure></p><p>Or an equivalent RediSearch query: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.SEARCH testidx &#x27;@a:&#123;z&#125; @b:[-inf (30]&#x27;</span><br></pre></td></tr></table></figure></p><p>Enjoy it!</p>]]></content>
      
      
      
        <tags>
            
            <tag> kvrocks </tag>
            
            <tag> query engine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Twice 的游戏列表</title>
      <link href="/twices-game-list/"/>
      <url>/twices-game-list/</url>
      
        <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>这里的“游戏”一词特指电子游戏。</p><p>注意，这是一份非常主观的游戏列表，并不能作为客观评价被参考。</p><h2 id="规则">规则</h2><p>依据我对已体验过的游戏的喜好程度将其分为 S, A, B ... F等级，依次对应从非常喜欢到非常不喜欢。 这里仅列出喜欢的游戏，故取其中 S,A, B, C 级。</p><h2 id="列表">列表</h2><h3 id="s-级">S 级</h3><ul><li><ahref="https://store.steampowered.com/app/501300/What_Remains_of_Edith_Finch">艾迪芬奇的记忆/ What Remains of Edith Finch</a></li><li><a href="https://store.steampowered.com/app/489830">上古卷轴5：天际/ The Elder Scrolls V: Skyrim</a></li><li><a href="https://bgm.tv/subject/62229">塞尔达传说：旷野之息 / TheLegend of Zelda: Breath of The Wild</a></li><li><a href="https://bgm.tv/subject/205917">超级马力欧 奥德赛 / SuperMario Odyssey</a></li></ul><h3 id="a-级">A 级</h3><ul><li><a href="https://store.steampowered.com/app/292030/_3/">巫师 3：狂猎/ The Witcher 3: Wild Hunt</a></li><li><a href="https://store.steampowered.com/app/319630">奇异人生 / Lifeis Strange</a></li><li><a href="https://store.steampowered.com/app/281990">群星 /Stellaris</a></li><li><ahref="https://store.steampowered.com/app/1190460/DEATH_STRANDING/">死亡搁浅/ DEATH STRANDING</a></li><li><ahref="https://store.steampowered.com/app/524220/NieRAutomata/">尼尔：机械纪元/ NieR:Automata™</a></li><li><a href="https://store.steampowered.com/app/620/Portal_2/">传送门2 /Portal 2</a></li><li><a href="https://bgm.tv/subject/12596">我的世界 / Minecraft</a></li><li><a href="https://bgm.tv/subject/210141">马力欧卡丁车8 豪华版 / MarioKart 8 Deluxe</a></li><li><a href="https://bgm.tv/subject/274530">超级马力欧创作家 2 / SuperMario Maker 2</a></li><li><a href="https://store.steampowered.com/app/17390/SPORE/">孢子 /SPORE™</a></li></ul><h3 id="b-级">B 级</h3><ul><li><ahref="https://store.steampowered.com/app/275850/No_Mans_Sky/">无人深空 /No Man's Sky</a></li><li><a href="https://store.steampowered.com/app/255710">城市：天际线 /Cities: Skylines</a></li><li><ahref="https://store.steampowered.com/app/477160/__Human_Fall_Flat/">人类一败涂地/ Human Fall Flat</a></li><li><ahref="https://store.steampowered.com/app/271590/Grand_Theft_Auto_V/">侠盗猎车手5/ Grand Theft Auto V</a></li><li><a href="https://store.steampowered.com/app/346010">围攻 /Besiege</a></li><li><ahref="https://store.steampowered.com/app/413150/Stardew_Valley/">星露谷物语/ Stardew Valley</a></li><li><ahref="https://store.steampowered.com/app/260230/Valiant_Hearts_The_Great_War__Soldats_Inconnus__Mmoires_de_la_Grande_Guerre">勇敢的心：世界大战/ Valiant Hearts: The Great War™</a></li><li><ahref="https://store.steampowered.com/app/496890/Replica/">Replica</a></li><li><ahref="https://store.steampowered.com/app/270880/American_Truck_Simulator/">美国卡车模拟/ American Truck Simulator</a></li><li><ahref="https://store.steampowered.com/app/736260/Baba_Is_You/">巴巴是你 /Baba Is You</a></li></ul><h3 id="c-级">C 级</h3><ul><li><a href="https://store.steampowered.com/app/222880">叛乱 /Insurgency</a></li><li><a href="https://store.steampowered.com/app/289070">文明6 /SidMeier’s Civilization® VI</a></li><li><ahref="https://store.steampowered.com/app/604450/Another_Adventure/">没有人知道的大冒险/ Another Adventure</a></li><li><ahref="https://store.steampowered.com/app/225540/Just_Cause_3/">正当防卫3/ Just Cause™ 3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文赏析 &quot;Stacked Borrows: An Aliasing Model for Rust&quot;</title>
      <link href="/stacked-borrows/"/>
      <url>/stacked-borrows/</url>
      
        <content type="html"><![CDATA[<p>这次我们介绍一篇发表在 POPL2020 上的文章《Stacked Borrows: AnAliasing Model for Rust》，其一作 Ralf Jung 目前是 MPI软件系统研究所的博士后研究员，曾经做出过一些程序理解、验证及证明相关的成果，并曾工作于Mozilla 的 Rust 程序语言组。</p><p>Rust 是一门年轻的系统级编程语言，也是 Mozilla 所期望的 C/C++的替代者。有趣的是，Rust 在允许像 C/C++那样的底层操作的同时提供了强有力的安全保证，这使开发人员更难写出有问题的代码；Rust也像其他现代语言一样提供了函数式的编程方法，并有着强大的工业界支持。</p><p>Rust使用了一套略为复杂的类型系统管理对象的生存周期及所有权。以引用类型为例，Rust中有两种引用类型：一种是可变引用（mutable reference,<code>&amp;mut T</code>），用以表示对一个类型为 <code>T</code>的对象的引用，对象可以通过这种引用被更改，但在这个引用的生命期（lifetime）结束之前，被引用对象不能再有其他引用；另一种是共享引用（sharedreference，<code>&amp;T</code>），其同样表示对一个类型为 <code>T</code>的对象的引用，但对象不能通过此引用被更改，而此时此对象可以拥有其他的共享引用。总结来说，在Rust 中别名（aliasing）和可变（mutation）不可能同时发生，如图一。</p><figure><img src="/images/stacked-borrows/1.png" alt="图一 Rust的引用类型" /><figcaption aria-hidden="true">图一 Rust的引用类型</figcaption></figure><p>显然，这种类型系统为我们提供了非常丰富的指针别名信息，如果编译优化器能够利用这种信息，可以减少很多静态分析的工作量，以提供更多的优化和更快的编译速度。如在图二的代码片段中，<code>unknown_function</code>可能是在其他编译单元（translationunit）中定义的函数，优化器只能通过耗时较长的链接期优化（link-timeoptimization）确定函数的性质。而当我们考虑到类型系统提供的别名信息时，由于<code>x</code> 是可变引用，且 <code>x</code> 的生存期一直持续到<code>unknown_function</code>被调用后，由可变引用的性质可知在此期间内不可能有任何引用指向<code>x</code> 所指向的对象。于是编译器能够断定 <code>test_unique</code>所返回的值一定是 <code>42</code>，而不可能被<code>unknown_function</code> 所更改。</p><figure><img src="/images/stacked-borrows/3.png" alt="图二 别名信息例子" /><figcaption aria-hidden="true">图二 别名信息例子</figcaption></figure><p>这些信息是 C/C++ 所得不到的。但在 Rust中，我们面临着一个严重的问题，即不安全代码块（unsafe code,<code>unsafe</code>）。在不安全代码块中，我们能够真正像 C/C++那样“为所欲为”地操作内存、使用指针、解引用任意地址。而不安全代码块有非常广泛的应用，Rust标准库中的许多数据结构均使用 <code>unsafe</code>实现，这些实现被包装成接口暴露给开发者使用。</p><p>我们可以使用 <code>unsafe</code>轻易地打破之前的优化。如在图三所示的代码片段中，我们声明了一个裸指针<code>ALIAS</code> 作为全局变量，随后使用 <code>unsafe</code> 块将<code>ALIAS</code> 指向 <code>l</code>，而在 <code>test_unique</code>中，我们传入的是 <code>l</code> 的可变引用，其中调用的<code>unknown_function</code> 使用了 <code>ALIAS</code>。显然，这使得<code>test_unique</code> 的返回值不再是 <code>42</code>，而是<code>7</code>，这是我们所不希望的。</p><figure><img src="/images/stacked-borrows/4.png" alt="图三 unsafe块例子" /><figcaption aria-hidden="true">图三 unsafe块例子</figcaption></figure><p>我们希望这个优化是永远有效的，不希望其被 <code>unsafe</code>块打破。所以与其允许这样的 <code>unsafe</code>块从而打破优化，不如直接认为这样的写法是未定义行为（undefinedbehavior）。一旦程序执行到未定义行为，接下来所发生的一切将不做任何保证。在以上的例子中，我们认为打破这样优化的操作将触发未定义行为，这意味着<code>test_unique</code> 的返回值将不被保证是<code>7</code>，相反，我们在此时能够返回 <code>42</code>。</p><p>实际上，许多语言都把某些行为定义为了“未定义行为”。最著名的当属 C 和C++，用其编写的程序很容易触发未定义行为。不仅如此，在 LLVM中为了实行某些优化也规定了一些未定义行为；而 Rust 的 <code>unsafe</code>块、甚至非 <code>unsafe</code> 代码中都有一些未定义行为的规定。</p><p>本文的核心工作即是定义了一种别名模型 StackedBorrows：其限定了指针在何时应如何访问内存，以确保在同一时间可变引用的独占性和共享引用的不可变性。并在两个方面证实了此模型是优秀的：一方面，其使用Coq证明了此别名模型提供了足够的限制以保证所实施的优化是正确的，即对可靠性做了证明；另一方面，其在一个Rust 的解释器 Miri上依据此模型实现了相应动态分析并在标准库测试用例上执行，以确保此模型没有对编程能力做太多限制，用于证明模型的可用性。</p><p>Rust 编译器对 Rust 的处理经过了许多方面，依次涉及 HIR、MIR 及 LLVM IR三种中间码。编译器在其中的 MIR 层实现了名为 Borrow Checker的静态分析器，负责对于不涉及 unsafe的代码的对象生存期和所有权做检查，而上文提到的 Rust语言对于引用的各种限制既是由 Borrow Checker负责检查，对于违反规则的代码给出编译错误。而 Stacked Borrows使用动态分析的方式实现在 Miri中，对于安全和不安全的代码块都能够做检查。</p><p>Stacked Borrows的核心思想之一是对同一对象的多个可变引用的生存期只能是栈式的嵌套关系，而不能有重叠。在图四的代码段中，<code>l</code>被 <code>a</code> 借用，而后又被 <code>b</code> 借用，随后依次使用<code>b</code>，<code>a</code>，<code>b</code> 更改了 <code>l</code>的值。编译器在第二次使用 <code>b</code> 时报错，这是因为在使用<code>a</code> 时就预示了 <code>b</code> 的生存期的结束，即预示<code>b</code> 已经将对象 <code>l</code> “还给”了<code>a</code>，此时根据可变引用的独占原则，已经不能再使用<code>b</code>，但程序却再次使用了<code>b</code>，从而引发了编译错误。这表明了可变引用的借用链条必须是如ABBA 这样的栈式关系，而非 ABAB 或其他形式。</p><figure><img src="/images/stacked-borrows/5.png" alt="图四 链式关系" /><figcaption aria-hidden="true">图四 链式关系</figcaption></figure><p>为了实现对于这样的关系的记录，Stacked Borrows对于每一个引用维护了一个唯一的标记，即每个引用由两部分组成：其一是所指向的地址，其二是一个唯一标记值。而对于每个地址，解释器都维护了一个栈，负责记录指针的借用链条。在对象被从任意可变引用<code>a</code> 借用给任意其他可变引用 <code>b</code> 时，视作一次对<code>a</code>引用的使用，若成功则向栈中压入此引用的标记值；而在任意可变引用<code>a</code> 被使用时，持续将元素弹出栈直到栈顶为 <code>a</code>的标记值。对于可变裸指针，模型将其视为一个单独的类别，且不使用标记区分不同的裸指针。模型规定，当使用某个指针时未能在栈中找到其标记值时，则会导致未定义行为。</p><p>不仅如此，作者定义了许多分析规则以支持对于可变引用、共享引用、裸指针及一些高阶特性，并给出了规则的可靠性的证明梗概。在实验方面，作者在实现了Stacked Borrows 的 Miri 上执行 Rust 标准库测试用例，发现了 11处对规则的违反，其中大部分已经在上报后被 Rust团队修复。作者接下来的工作将是对并发方面的考虑以及将 Stacked Borrows集成到其之前的工作 RustBelt 中，这个工作给出了对 Rust的类型系统及一个类似 Rust MIR 的语言的形式化验证。</p>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> formal verification </tag>
            
            <tag> rust </tag>
            
            <tag> paper </tag>
            
            <tag> aliasing model </tag>
            
            <tag> dynamic analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frama-C 及 SeaHorn 调查报告</title>
      <link href="/report-on-frama-c-and-seahorn/"/>
      <url>/report-on-frama-c-and-seahorn/</url>
      
        <content type="html"><![CDATA[<h1 id="背景">背景</h1><h2 id="形式化验证">形式化验证</h2><p>形式化验证旨在用数学方法对系统建模以证明其正确性，特别是用以验证软件或硬件系统。其在真实的系统上构建对应的抽象数学模型，进而对抽象模型提供形式化证明以证明真实系统的正确性。对于针对软件的形式化验证，常用的技术包括模型检查、抽象解释及演绎验证等。</p><p>模型检查将程序视为状态机，用初始状态及状态转移函数描述系统，通过遍历程序的状态以验证程序的所有可能的状态都满足给定的性质。</p><p>一种常用的模型检查方法使用时序逻辑式描述系统规范，被称为时序规范（TemporalSpecifications）方法。这种方法将被规范的程序的可能的执行对应为此规范可能的模型，使用时序逻辑形式化程序语义以验证程序状态的正确性。</p><p>抽象解释[8]在某些方面上能够被视为模型检查的，其是用以获得某些特定性质的验证技术，其将代码中的具体值映射到抽象值，并在抽象值域上演算以至收敛，从而在某个限度上反映运行时程序的演算。</p><p>其主要基于演变系统（Transition System）、序理论（OrderTheory）以及不动点定理（Fixed-point Theorem）。对于具体值域 <spanclass="math inline">\(C\)</span> 及其上的偏序关系 <spanclass="math inline">\(\subseteq\)</span> 与抽象值域 <spanclass="math inline">\(A\)</span> 及其上的偏序关系 <spanclass="math inline">\(\sqsubseteq\)</span>，其构成的完全格 <spanclass="math inline">\((C, \subseteq )\)</span> 与 <spanclass="math inline">\((A, \sqsubseteq )\)</span> 以及两个映射 <spanclass="math inline">\(\alpha:\ C \rightarrow A,\ \ \gamma:\ A\rightarrow C\)</span>，为使得分析结果可靠需满足伽罗瓦连接（GaloisConnection），即 <span class="math inline">\(\forall c \in C,\ a \in A.\\alpha(c) \sqsubseteq a \Leftrightarrow c \subseteq\gamma(a)\)</span>，记作 <span class="math inline">\((C, \subseteq )\leftrightharpoons_{\alpha}^{\gamma}(A, \sqsubseteq)\)</span>。为使得语义函数在有限次的迭代下即可达到不动点，需使得语义函数为格上的单调函数。抽象解释的一个经典案例是区间分析（IntervalAnalysis）。</p><p>演绎验证从系统规范出发产生一系列证明义务（ProofObligations），并将其证明委托至定理证明器。其往往通过归纳法的方式得到不变量以保证程序状态的正确性。</p><h2 id="静态分析">静态分析</h2><p>静态分析在程序执行之前进行分析以理解其行为、确定一些特定的性质是否得到满足，其主要方法论为抽象与近似。一般来说，分析算法不需要关心程序的全部语义，而只需要理解算法的设计目标所感兴趣的语义子集。故程序的具体语义可以被映射到某个抽象域，进而进行分析，这种方法被称为抽象。而既然分析算法不可能给出完全确定的解，近似解也就成为其所追求的主要目标。分析算法将给出具体语义的近似，以得到尽可能精确的结果，这种方法被称为近似。</p><p>静态分析随编译优化技术发展而来，其主要技术包括数据流分析、指针分析、过程间分析、符号执行及抽象解释等。其中，数据流指某些特定的数据在控制流图上变换及传播的过程，而对数据流进行分析的方法被称为数据流分析；指针分析旨在得到对象间的可能存在的引用关系，以构建更精确的调用图；过程间分析相对于过程内分析，指考虑到过程调用的分析方法，其在分析时需要考虑上下文敏感性。</p><p>符号执行使用符号值代替具体值作为输入以近似程序的具体执行，并在分支处求解符号表达式构成的条件约束以确定执行路径的可能情况，从而使其往往比单元测试更加可靠。为了使符号值能够像具体值那样在程序中被执行，我们需要一个符号解释器以模拟程序的执行，并在赋值时形成符号表达式以广义地表达程序执行时具体值的可能情况。当遇到分支时，路径条件所对应的符号表达式即可委托SMT求解器以判断是否被满足。</p><h1 id="介绍">介绍</h1><h2 id="frama-c">Frama-C</h2><p>一些新的软件分析、验证及测试技术如抽象解释（AbstractInterpretation）、Concolic测试（Concolic Testing）及演绎验证（DeductiveVerification）等在过去的几十年中被提出。但在运用到工业界的过程中遇到了挑战，如如何使得现有的技术适应大规模的业界代码、理解业界常用的语言特性对大规模代码结构的影响；如何使得各种分析技术可以互相协作；以及如何使得分析的结果可靠（Sound），即可以给出不存在未被发现的对约束的违背的证明。</p><p>Frama-C [1] [2]旨在构建一个可以解决上述问题的、对C语言（ISOC99）代码的软件分析验证平台。平台的核心提供了插件系统使得构建在其上的检查插件能够互相依赖、协作，并使用ACSL作为规范语言提供约束。在程序分析方面，Frama-C并不仅局限于静态分析，其有动态分析的能力，以及提供各种交互式分析的发展空间。</p><p><img src="/images/report-on-frama-c-and-seahorn/image1.png"style="width:5.76806in;height:2.29861in" /></p><p>表1.1 Frama-C 插件及描述</p><p>Frama-C的分析及验证算法完全实现在各个插件上，主要的插件如表1.1。这些插件实现了广泛的程序分析技术，并建立起插件间的基于约束的依赖关系。其中不仅包括上文中提到的分析技术，还包含了依赖分析（DependencyAnalysis）、程序切片（Program Slicing）等。</p><p>ACSL（ANSI/ISO C Specification Language）[3]是C语言的规范语言，实现了对于C语言的约束编程（ConstraintProgramming）。其可以用类似霍尔逻辑的方式指定C语言代码如函数、循环等的特性及约束，并以嵌入注释块的方式避免扩展C语法带来的兼容性问题。</p><p>对于函数，ACSL能够指出其在初始时满足什么条件（requires），在执行结束后满足什么约束（ensures），以及在执行过程中改动了哪些内存区域（assigns）等，如图1.2中swap函数的ACSL指出其需要在函数被执行前指针a, b 合法且所指向的内存区域不重叠、保证在函数被执行后 *a 值与 *b值被交换、且函数仅改动了内存中 *a, *b 的值。</p><p>对于循环，ACSL能够指出循环不变量（loopinvariant）、循环所改动的内存区域（loopassigns）等，如图1.3中指出了两个循环不变量（<spanclass="math inline">\(i \in \left\lbrack 0,10 \right\rbrack\)</span> 和<span class="math inline">\(\forall j \in \mathbb{\text{Z. }}j \in\left\lbrack 0,i \right) \Rightarrow a_{j} =j\)</span>）以及循环只改动了变量i及下标从0到i-1的数组a，还能指出循环一定会终止，以一个递减至零的循环变量的形式（loopvariant），对于图1.3这个循环变量可以是"loop variant 10 - i"。</p><p><img src="/images/report-on-frama-c-and-seahorn/image2.png"style="width:5.76806in;height:1.47708in" /></p><p>图1.2 对swap函数的ACSL规范</p><p><img src="/images/report-on-frama-c-and-seahorn/image3.png"style="width:5.76806in;height:1.43194in" /></p><p>图1.3 对数组赋值循环的ACSL规范</p><p>CIL（C Intermediate Language）[4]是一种高阶中间语言，并包含一系列工具，以使在其上进行的程序分析及代码变换更简便。比起直接由C的语法构建AST，CIL将C中一些复杂结构用简单的结构表示；而比起类似三地址码的低阶IR，CIL具有更高阶的语言结构。由于忽略了AST中冗余的语义信息、丰富了低阶IR丢失的语义信息，程序分析更容易在CIL上进行。</p><h3 id="理论基础">理论基础</h3><p>Frama-C提供Value插件进行基于抽象解释的值分析（ValueAnalysis），其在前向数据流分析的基础上完成对整个程序的分析。</p><p>在Frama-C中，演绎验证由WP插件完成。WP插件实现了最弱前提（WeakestPrecondition）演算为ACSL注释提供验证条件。</p><p>Concolic测试 [9]旨在通过符号执行（Symbolic Execution）[10]获得每条执行路径的约束，从而生成具有更大路径覆盖率的输入，以丰富测试用例。其主旨并不是验证程序正确性，而是通过提高测试覆盖率发现软件缺陷。PathCrawler插件为Frama-C提供Concolic测试技术，其使用Colibri作为约束求解工具。</p><h3 id="技术及实现">技术及实现</h3><p><img src="/images/report-on-frama-c-and-seahorn/image4.png"style="width:5.76806in;height:3.25486in" /></p><p>图1.4 Frama-C 功能结构</p><p>Frama-C使用OCaml编写，由三部分构成，在CIL的基础上构造了核心组件，为上层的分析插件提供基本的代码解析、操作日志、插件通讯、AST遍历等服务接口。而所有的分析算法以插件的形式模块化地被实现，如图1.4。</p><p>Frama-C的核心组件提供了一个修改版的CIL，其将C语言代码转换为一种中间表示（下文也称为AST），这种中间表示消除了一些对于程序分析无意义的语言细节，如不同的种类的循环、复杂的带有副作用的表达式等。被修改的CIL同时提供了解析ACSL为AST的能力，这使得规范语言的语义与C语言语义可以以同样的方式被呈现。</p><p>除此之外，为了使得分析插件的开发更加便利，核心组件提供了一系列的基础设施，包括对于用户参数的统一处理，对于用户操作记录的合成和重放，对于分析结果的序列化机制，以及一种AST遍历访问机制。</p><p>项目（Project）的概念使得用户可以同时在多个C程序上使用Frama-C，或是同时以不同的参数在同一C程序上使用Frama-C，一个项目保存了一个C程序所需的全部信息以及分析插件的参数及结果，这使得项目间完全分隔开来。项目也使得被插件处理过的AST与原始的AST一致，以便于参考及回溯。</p><p>Frama-C的插件之间有两种协作（通讯）方式，一种是简单的依赖关系，即一个分析插件可以使用其他一个或多个分析插件产生的结果，被称为依次序互操作，即这种互操作是按顺序进行。另一种更加有趣，其可以做到各分析插件同时进行，并相互操作，共同构造分析的结果，这种途径源于各插件可以写出ACSL（从AST层面上）作为约束条件。</p><p>某个插件在无法由自身验证某个程序点的约束时可以将此约束写入ACSL，以委托其他插件验证。内核提供了将插件写入的ACSL集合起来供其他插件使用的能力。如Value插件本身无法验证指针p的合法性（即是否存在可能的NPD，空指针解引用），其将生成无法证明的ACSL注释"assert\valid(p)"，对 assert的违背将导致分析终止，故Value现在可以认为此性质成立。而此性质随后将被WP插件证明，或是使用E-ACSL在运行期检查此性质的合法性。这种通讯方式使得插件间的互操作能力极大地增强。</p><p>Frama-C实现了Frama-Clang以提供对C++程序的分析能力。此插件由两部分构成：第一部分是一个Clang 插件（依赖libClang及LLVM，可支持到LLVM/Clang9.0），其利用Clang解析C++代码以生成ClangAST，并简化此AST以便后续处理；第二部分是一个Frama-C插件，其将被简化的ClangAST转换为Frama-C AST（即CIL）。这使得各个插件可以不被修改既可拥有对C++程序的分析功能。</p><p>Frama-C也提供了GUI，以便各个分析的操作及结构更为直观，并拥有更强的交互能力。GUI提供了类似IDE的交互方式使得用户逐语句地、逐符号地了解分析结果。</p><h3 id="特点及展望">特点及展望</h3><p>与工业界目前使用的一些分析工具（如 Clang StaticAnalyzer、CppCheck、Coverity等）不同，Frama-C具有可靠性。工业界绝大多数分析工具在分析过后只能给出既不可靠（Sound）又不完备（Complete）的结果，而Frama-C的分析结果保证了安全。</p><p>尤其引人注目的是，Frama-C的插件系统使得各种分析及验证技术之间具有很强的互操作性。这使得这些技术功能紧密结合起来共同参与分析，从而使得分析的结果更具有普适性。</p><p>在软件工程上看，模块化是Frama-C的显著优势，通过插件和项目机制，Frama-C能够做到低耦合，高内聚地完成各种分析算法，使得逻辑之间不会过度相互干扰，而又可以以一种合理的方式相互依赖。</p><p>通过上面的几点，Frama-C使得大规模代码的分析及验证成为可能。对于业界大量的代码，Frama-C能以合理的方式组织分析逻辑，以大量的插件覆盖分析的能力范围，使得到的分析结果足够有意义。</p><p>Frama-C正在被广泛关注，无论是学术界还是工业界。其已经有12年的历史，现在已经形成了丰富的插件生态，以及活跃的用户及开发者社区。</p><p>在学术上，许多课题组使用Frama-C实现新的分析技术，或是应用Frama-C完成对于一些问题的分析，如插件Jessie使用Why3完成了演绎验证；一些研究者在其上面实现了污点分析（TaintAnalysis）；有人将Frama-C用于验证智能卡上的物理攻击；或是使用ACSL提供对于最坏情况下运行时间成本的断言。</p><p>在工业界，许多公司在尝试使用Frama-C。有的公司尝试使用Frama-C构建对于特定的代码规范的验证，或是使用Value插件验证控制流及数据流的正确性。通过Frama-C也能够找到知名开源软件中的缺陷，如QuickLZ、PolarSSL等。</p><h2 id="seahorn">SeaHorn</h2><p>SeaHorn[5]是一个基于LLVM的软件验证框架，其最重要的特点是借助模块化的设计将编程语言的具体语法、操作语义和验证语义分开处理。</p><p>SeaHorn具有几个显著的特色，它使用了既高效又精确的过程间分析技术编码验证条件（VerificationConditions）,提供了对验证精度的灵活控制，利用了抽象解释和模型验证的最新成果，以及使用Horn子句（HornClauses）作为验证条件的中间表示，使得不同的验证工具可以在统一接口下工作。</p><p>SeaHorn不仅可以自动地验证用户给定的断言，还能验证关于软件安全的固有性质，如其提供了对于缓冲区溢出和整形溢出的内置检查。</p><p>LLVM项目[6]提供了模块化的编译技术及其工具链、支持库，旨在同时使学术界和工业界使用这些技术。其核心库提供了与源代码及目标（机器）代码无关的优化器及一中低阶的中间表示（LLVMIR），并提供了从LLVM IR 到多种流行的架构的代码生成。</p><p>LLVM项目提供了Clang [7]作为C、C++、Objective C 语言的前端生成LLVMIR（或称为LLVM字节码），还有一大批其他语言（如Rust、Go、Swift等）选择LLVMIR作为中间表示或是提供了对LLVMIR的代码生成。这使得许多语言都可以使用LLVM相关的或是基于LLVM工具，针对LLVMIR的技术具有广泛的应用空间。</p><p>Horn子句（Horn Clauses）是最多存在一个真值项的析取式，对于原子 <spanclass="math inline">\(p,\ q,\ \ldots,\ t,\ u\)</span>, Horn子句可以写作<span class="math inline">\(\neg p \vee \neg q \vee ... \vee \neg t \veeu\)</span> 或是 <span class="math inline">\(u \leftarrow p \land q \land\ldots \land t\)</span>。而CHC（Constrained HornClauses）用以描述验证条件，对于函数符号、谓词符号及变量的集合<spanclass="math inline">\(\mathcal{F,\ P,\ V}\)</span>，可表示为 <spanclass="math inline">\(\mathcal{\forall V}.\ h\lbrack X\rbrack \leftarrow\phi \land p_{1}\lbrack X_{1}\rbrack \land ... \land p_{k}\lbrackX_{k}\rbrack,\ \ k \geq 0\)</span>,其中 <spanclass="math inline">\(\phi\)</span> 是对于 <spanclass="math inline">\(\mathcal{F}\)</span> 和 <spanclass="math inline">\(\mathcal{V}\)</span> 的约束，<spanclass="math inline">\(X,X_{i}\mathcal{\subseteq V}\)</span>, <spanclass="math inline">\(p \in \mathcal{P}\)</span>，<spanclass="math inline">\(h\)</span>可能属于<spanclass="math inline">\(\mathcal{P}\)</span>, 也可能不属于。简记为<spanclass="math inline">\(h\lbrack X\rbrack \leftarrow \phi,p_{1}\lbrackX_{1}\rbrack,...,p_{k}\lbrack X_{k}\rbrack\)</span>。</p><h3 id="理论基础-1">理论基础</h3><p>SeaHorn的抽象解释在早期版本中由IKOS直接提供，而在目前的版本中使用了自主开发、基于IKOS的Crab。为了避免抽象域在迭代时的精度丢失，IKOS更适合为其他验证引擎提供不变量，而不是单独作为后端引擎。</p><p>SeaHorn使用了基于SMT的模型检查程序SPACER，其与其他基于SMT的算法的区别在于在检查程序的合法性时会不断生成对个别过程或Horn子句的未知谓词的局部可达性的询问。</p><h3 id="技术及实现-1">技术及实现</h3><p><img src="/images/report-on-frama-c-and-seahorn/image5.png"style="width:5.76806in;height:2.12708in" /></p><p>图1.5 SeaHorn的基本结构</p><p>SeaHorn使用C++编写，提供了一个可供扩展及自定义的框架以支持在其上实现新的分析技术。它基于LLVM5.0，将整体结构划分为三层，如图1.5。</p><p>前端的作用是对程序做预处理（指代码解析、代码优化等）以生成LLVMIR,这个步骤会对之后的验证产生重大的影响。SeaHorn的早期版本提供了两个不同的前端。一种是旧版，仅支持C语言（ISOC99），主要用于参加SV-COMP（Competition on SoftwareVerification，TACAS）而开发的前端。其首先使用CIL处理代码，以做一些琐碎的代码变换，如插入隐式定义的函数，初始化局部变量等，随后使用llvm-gcc（此工具仅存在于LLVM的早期版本2.x，随后被DragonEgg替代）将其转换为LLVMIR。然后将进行一些代码优化以方便之后的验证，如初始化未被初始化的寄存器，内联函数，转换为SSA形式，消除不可达代码，简化控制流图等（这些功能大部分由LLVM本身提供）。由于这个旧版前端不够模块化，使用了一些被废弃的工具，且只支持C语言，故有很大的局限性且难以维护。</p><p>新的前端被称为过程间前端，支持任意可以转换到LLVMIR的程序代码，这使得语言的局限性被打破，如C、C++、Rust等语言都可以使用此前端。对于LLVMIR，此前端有两部分处理组件，第一部分类似旧版的处理，以方便之后的验证；第二部分则致力于简化代码变换的范围以至于即使关闭这个预处理过程之后的验证也会得出正确的结果。在处理断言可能在调用图中过深的问题时，其使用混合语义（MixedSemantics）的概念处理代码，其核心思想是当函数可能失败时将函数内联入调用点（保留原函数），而将原函数内的断言（assert）替换为假设（assume），此时当函数成功时会进入原函数，使得这种替换是安全的。</p><p>SeaHorn的中端在输入的LLVM IR中得到以CHC（Constrained HornClauses）为表示的验证条件，并可以调节编码及精度。其提供了两种验证条件的编码方式，一种被称为小步编码（SSE,Small-Step Encoding），另一种被称为大块编码（LBE, Large-BlockEncoding），用户可以选择一种编码以生成CHC，通常LBE效率更高，而SSE的结果更有意义。一个使用LBE生成CHC的示例如图1.6，此程序包含了一个未确定终止条件的循环以及两个在循环中被赋值的变量，而我们希望证明在循环结束时<span class="math inline">\(x \geqy\)</span>。对应于控制流图中的每一个基本块 <spanclass="math inline">\(l_{i}\)</span>，都有一个以 <spanclass="math inline">\(p_{i}(x_{1},...x_{n})\)</span>为头部的Horn子句被编码，其中 <span class="math inline">\(\{x_{1},...x_{n}\mathcal{\} \subseteq V}\)</span> 是在基本块 <spanclass="math inline">\(l_{i}\)</span> 中的活变量（LiveVariables）的集合，<span class="math inline">\(p_{i}\mathcal{\inP}\)</span>。子句 <span class="math inline">\(\left\langle 1\right\rangle\)</span> 指出基本块 <spanclass="math inline">\(l_{0}\)</span> 可达，子句 <spanclass="math inline">\(\left\langle 2 \right\rangle\)</span> 指出若基本块<span class="math inline">\(l_{0}\)</span> 可达则 <spanclass="math inline">\(l_{1}\)</span> 可达，且在此程序点 <spanclass="math inline">\(x = 1 \land y = 0\)</span>，而子句 <spanclass="math inline">\(\left\langle 5 \right\rangle\)</span> 指出控制流从<span class="math inline">\(l_{2}\)</span> 到 <spanclass="math inline">\(l_{1}\)</span> 时变量的状态发生变化，即<spanclass="math inline">\(x‘ = x + y \land y’ = y + 1\)</span>。</p><p><img src="/images/report-on-frama-c-and-seahorn/image6.png"style="width:5.76806in;height:3.12153in" /></p><p>图1.6 (a)程序代码 (b)控制流图 (c)验证条件 对照示例</p><p>中端中还包括了具有不同抽象级别的验证语义生成，以供用户调节，从低精度到高精度分别是：仅对数值寄存器进行建模；对数值及地址（被建模为整数）寄存器进行建模，不包括内存申请的地址；对数值、地址寄存器及内存堆（被建模为不重叠的数组的集合）建模。</p><p>其后端将CHC作为输入最终得到分析结果。SeaHorn使用了基于SMT的模型检查引擎如SPACER及GDPR，还使用了基于抽象解释的分析器IKOS（InferenceKernel for Open StaticAnalyzers）。CHC作为统一表示使得验证条件可以将多种引擎用于SeaHorn。</p><h3 id="特点及展望-1">特点及展望</h3><p>SeaHorn 使用LLVMIR及CHC将编程语言的具体语法同验证技术所需要的语义分割开来，使得验证、分析工作不需要在琐碎的、没有必要的语法细节上耗费时间。它使用LLVM将特定语言代码处理为LLVMIR以忽略语言细节，并简化、形式化语义，而后使用CHC表示验证条件。这样的分层使得不同阶段的工作被分隔开，以减轻新技术实现的工作量。</p><p>它使用新的过程间分析技术确保分析的高效和精确。它可以将调用图深处的断言提升到主函数中，在不内联的情况下得到函数的数据流，以及不把表达力限制在线性算术上。</p><p>对于开发者，它可以提供自定义验证语义的能力；而对于用户，有多种验证精度可以调节。不仅可以选择LBE或是SSE，还可以自动地由SSE提升为LBE；而对于验证的建模也可以在仅数值寄存器到包含内存堆间选择。</p><p>它使用CHC作为验证语义的中间语言，从而灵活地提供了对于验证条件的多种编码方式。CHC还使得SeaHorn具有了对多种验证工具的兼容能力。</p><p>它构建在LLVM之上，这使得对于LLVM的其他工作可以轻易地被SeaHorn利用，包括新的语言的前端可以无更改地被SeaHorn支持，适用于LLVM的代码变化工具以及周边工具也能够被SeaHorn使用。</p><p>SeaHorn在SV-COMP 2015[11]中的控制流分析及驱动程序分析方面取得了第二名的成绩，并在对工业级自动驾驶软件的代码分析时结果能够不弱于来自NASAAmes研究中心的分析器。</p><h1 id="比较">比较</h1><h2 id="共同点">共同点</h2><p>Frama-C和SeaHorn都保证其对于程序行为的近似结果的可靠性，即若分析结果为安全则一定是安全的。这个特点为其应用于工业界提供了保障，用户无需担心分析过后是否有可能的错误运行，这使它们与某些启发式的分析引擎区分开。</p><p>模块化的结构是Frama-C和SeaHorn的显著特征。Frama-C将分析及验证技术构件在被剥离出的核心框架之外，使这些技术作为插件并提供互相沟通的能力使它们合作完成分析任务；而SeaHorn将架构分为三层，不同层间有各自的任务及表述形式，使得各层之间互相独立，利于维护。</p><p>模块化使得这两个平台都提供了相当的扩展性。Frama-C的插件生态丰富，许多学者使用Frama-C以减轻新分析理论的实现成本；SeaHorn提供给用户及开发者多种对编码及精度的调控，以统一的接口对接了多个验证工具。</p><p>两者都从中间语言入手分析，以将关注点放在与程序安全性相关的语义上。Frama-C使用CIL预处理C语言代码，使得分析不受一些纯语法的语言结构干扰；（使用新版前端的）SeaHorn从LLVM字节码着手分析，使得许多高阶的语义得到分解。</p><p>验证语义的抽象和结构化是两者的工作之一。SeaHorn使用CHC统一表示验证条件，使得多种后端可以被嵌入并协调工作；Frama-C使用ACSL作为程序性质通用表示形式，并将插件间通讯能力建立在其上。</p><p>两者都使用了抽象解释以提供对实际执行的近似解。在Frama-C中这个技术由Value插件提供，而在（新版后端的）SeaHorn中由子项目Crab提供。</p><h2 id="优缺点">优缺点</h2><p>SeaHorn 基于LLVM，并使用LLVMIR作为前端的输入语言在中端被处理为CHC，这使得它具有广泛的语言适应能力，丰富的、参与了LLVM生态的语言如C、C++、Rust、Go、Swift等都能够直接进行分析；而Frama-C基于CIL，这限制了其语言处理能力，虽然其提供了Frama-Clang用以借助Clang前端将C、C++及ObjectiveC，但依旧无法与SeaHorn的语言普适性相提并论。另一方面，CIL提供了更高抽象层次的中间表示，这使得它更容易进行语言特性相关的分析；而SeaHorn既无法顾及各语言的特定结构（即使LLVM可以通过Metadata传递高级信息），也不能像Frama-C那样扩展CIL以提供对程序性质的描述。</p><p>Frama-C对插件及项目的抽象使得其在模块化方面更胜一筹，这让不同技术间能够逻辑独立并以规范的方式相交互。配合比SeaHorn更长的历史，Frama-C已经被学界广泛接受并用以实现新技术，其第三方插件数量远多于SeaHorn后端的验证模块。</p><p>在验证语义上看，SeaHorn使用CHC作为验证条件的统一表示，并在中端将LLVM字节码转换为CHC，使操作语义与验证语义相分离，让后端的验证在CHC上进行，而不必关心LLVMIR的细节；而Frama-C仅将源代码处理为CIL，并将ACSL也用CIL的方式表述，使得其对验证语义的表示并不独立，在一定程度上增加了插件实现的工作量。</p><p>在涉及的技术范围上看，Frama-C不仅使用了静态分析技术，还应用了动态分析技术及软件测试技术。它使用PathCrawler插件提供Concolic测试技术，使用E-ACSL插件以实现在运行期检查程序是否遵循了ACSL注释，使用Slicing插件提供程序切片技术，使用Mthread插件扩展Value插件以实现对并行程序行为的近似，提供了Sante插件使用测试技术增强静态分析结果，旨在发现运行期可能的除以零错误及数组越界等。</p><p>Sante插件是Frama-C综合各种分析技术以实现更精确的分析的典范：其首先使用Value插件分析程序以发现可能存在的缺陷，并在缺陷处使用Slicing插件得到一些切片，随后PathCrawler插件将被用于发现每个切片引发实际错误的执行路径的测试用例，而被发现与Value分析结果一致的测试用例所对应的缺陷则会被报告给用户，如图2.1。对比Frama-C，SeaHorn所使用的分析、验证技术便略显单一。</p><p><img src="/images/report-on-frama-c-and-seahorn/image7.png"style="width:5.76806in;height:3.35in" /></p><p>图2.1 Sante插件工作流程概览</p><p>在一次已知的实际比较[12]中，SeaHorn被证实可以以更快的运行速度和更少的代码开销验证近乎于Frama-C两倍的需求。且得出这样的结论所作的实验中，对Frama-C的操作由经验丰富的用户完成，而对SeaHorn进行操作的用户是首次使用SeaHorn。</p><h2 id="应用方式及场景">应用方式及场景</h2><p>Frama-C与SeaHorn都致力于以统一的框架为学术界和工业界提供帮助，并获得了不同程度的成功。Frama-C早已成为软件分析及验证研究者的技术实现工具，安全学者的应用工具，以及工业界对于重要软件的实验性质量保证工具；SeaHorn借助SV-COMP及对航天软件的验证实例证实了其具有较高的可用性及扩展性。</p><p>Frama-C更适合更广泛的程序分析技术开发及使用。对CIL的增强及众多涉及不同领域技术的插件使得新技术的开发更易结合已有的技术进行，而综合来看Frama-C对核心框架的设计足够饱满，内含了足够的基础设施以支持新插件的开发。</p><p>SeaHorn将验证语义从操作语义中剥离令其对验证相关的技术更友好，特别是基于Horn子句的验证技术，CHC使得LLVM字节码中的验证条件被形式化，在验证时无需关心有未定义的行为。另一方面，SeaHorn的多语言优势使得其应用范围更大，更容易在不同语言中分析问题并归并结果。</p><h1 id="其他工具">其他工具</h1><h2 id="clang-static-analyzer-及-klee">Clang Static Analyzer 及KLEE</h2><p>Clang Static Analyzer（CSA） [13][14]是基于LLVM/Clang的静态分析器，旨在发现源代码中的安全性缺陷及违背代码规范的片段。有趣的是，它并未使用LLVMIR，而是直接从ClangAST上建立控制流图，并在其上使用符号执行技术建立"爆炸图"（ExplodedGraph）：将变量用符号模拟，通过约束求解（可以使用内置的求解器或委托给Z3Prover）得出运行期可能存在的全部执行路径，并将路径放入图中。这使得图的节点数暴增，图的命名也许就来源于"路径爆炸"。为了分析内存安全问题，CSA还对内存堆进行建模以在符号执行期间随时模拟内存访问行为。CSA正在通过clang-tidy（基于LLVM/Clang的"linter"，能够委托CSA进行分析）广泛应用于业界。</p><p>KLEE[15]是基于LLVM的符号虚拟机，使用符号执行检查程序是否满足给定的约束条件。KLEE从LLVMIR入手分析，具有更强的语言适应能力，并在分析的过程上使用了比CSA更灵活的技术。</p><p>比起Frama-C及SeaHorn，CSA于KLEE的目标并不是给出可靠的分析结果或是验证程序是否安全。CSA倾向于志在找到现实世界中复杂程序的缺陷，而KLEE旨在为复杂程序生成高覆盖率的测试。</p><h2 id="boogie-vcc-及-smack">Boogie, VCC 及 SMACK</h2><p>如SeaHorn的CHC或是Frama-C加入ACSL支持的CIL那样，Boogie[16]是一种中间验证语言，旨在为验证技术提供语言层的抽象。与其同名的工具Boogie对于给定的Boogie中间语言程序生成验证条件，以传入一些约束求解器得到结果。VCC[17]构建在Boogie之上，旨验证并行C语言程序，而SMACK [18]提供了从LLVMIR到Boogie语言的转换能力。</p><p>与Frama-C和SeaHorn不同的是，Boogie本身不能被称为是一个框架，没有提供插件机制所需的基础设施以及使得建立在其上的验证技术相互利用的统一接口，这可能使得基于Boogie实现验证技术需要更多的工作量。</p><h1 id="引用">引用</h1><hr /><hr /><p>[1] F. Kirchner, N. Kosmatov, V. Prevosto, J. Signoles and B.Yakobowski, "Frama-C: A software analysis perspective," <em>FormalAspects of Computing,</em> pp. 573-609, 2015.</p><p>[2] L. Correnson, P. Cuoq, F. Kirchner, A. Maroneze, V. Prevosto, A.Puccetti, J. Signoles and B. Yakobowski, Frama-C User Manual, Release20.0 (Calcium), 2018.</p><p>[3] P. Baudin, P. Cuoq, J.-C. Filliâtre, C. Marché, B. Monate, Y. Moyand V. Prevosto, ACSL: ANSI/ISO C Specification Language, Version 1.14,2018.</p><p>[4] G. C. Necula, S. McPeak, S. P. Rahul and W. Weimer, "CIL:Intermediate Language and Tools for Analysis and Transformation of CPrograms," in <em>International Conference on CompilerConstruction</em>, 1.</p><p>[5] A. Gurfinkel, T. Kahsai, A. Komuravelli and J. A. Navas, "TheSeaHorn Verification Framework," in <em>International Conference onComputer Aided Verification</em>, 2015.</p><p>[6] LLVM Developer Group, "The LLVM Compiler Infrastructure Project,"[Online]. Available: http://llvm.org.</p><p>[7] LLVM Developer Group, "Clang: a C language family frontend forLLVM," [Online]. Available: http://clang.llvm.org.</p><p>[8] P. Cousot and R. Cousot, "Abstract interpretation: a unifiedlattice model for static analysis of programs by construction orapproximation of fixpoints," in <em>Proceedings of the 4th ACMSIGACT-SIGPLAN symposium on Principles of programming languages</em>,1977.</p><p>[9] P. Godefroid, N. Klarlund and K. Sen, "DART: directed automatedrandom testing," in <em>Proceedings of the 2005 ACM SIGPLAN conferenceon Programming language design and implementation</em>, 2005.</p><p>[10] J. C. King, "Symbolic execution and program testing,"<em>Communications of the ACM,</em> 1976.</p><p>[11] D. Beyer, "Software Verification and Verifiable Witnesses(Report on SV-COMP 2015)," in <em>International Conference on Tools andAlgorithms for the Construction and Analysis of Systems</em>, 2015.</p><p>[12] A. Alshnakat, "SeaHorn Comparison to VCC and Frama-C," in<em>Automatic Verification of Embedded Systems Using Horn ClauseSolvers</em>, 2019, pp. 52-54.</p><p>[13] LLVM Developer Group, "Clang Static Analyzer," [Online].Available: https://clang-analyzer.llvm.org.</p><p>[14] A. Degrachev, Clang Static Analyzer: A Checker Developer'sGuide, 2016.</p><p>[15] C. Cadar, D. Dunbar and D. Engler, "KLEE: Unassisted andAutomatic Generation of High-Coverage Tests for Complex SystemsPrograms," in <em>USENIX Symposium on Operating Systems Design andImplementation</em>, 2008.</p><p>[16] K. Rustan and M. Leino, "This is Boogie 2," Microsoft Research,2008.</p><p>[17] E. Cohen, M. Dahlweid, M. Hillebrand, D. Leinenbach, M. Moskal,T. Santen, W. Schulte and S. Tobies, "VCC: A Practical System forVerifying Concurrent C," in <em>International Conference on TheoremProving in Higher Order Logics</em>, 1.</p><p>[18] Z. Rakamaric and M. Emmi, "SMACK: Decoupling Source LanguageDetails from Verifier Implementations," in <em>International Conferenceon Computer-Aided Verification</em>, 2014.</p>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frama-c </tag>
            
            <tag> seahorn </tag>
            
            <tag> static analysis </tag>
            
            <tag> formal verification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Twice 的番剧列表</title>
      <link href="/twices-anime-list/"/>
      <url>/twices-anime-list/</url>
      
        <content type="html"><![CDATA[<h2 id="声明">声明</h2><p>这里的“番剧”一词特指日本动画剧集/电影。</p><p>注意，这是一份非常主观的番剧列表，并不能作为客观评价被参考。</p><h2 id="规则">规则</h2><h3 id="情怀作">情怀作</h3><p>对于一些成为我一生中理想信念的重要组成部分的作品，将单独列为「情怀作」，不再纳入「神作计划」</p><h3 id="神作计划">神作计划</h3><p>对于在观赏后触动或改变了人生观和价值观、并能够使这种影响持续一段时间的作品，纳入「神作计划」，并根据影响程度从高到低分为A, B, C 三类，同类间不分排名</p><h3 id="伟大工匠">伟大工匠</h3><p>收录了那些创作了触动人心的番剧的导演们</p><h2 id="列表">列表</h2><h3 id="情怀作-1">情怀作</h3><ul><li><a href="https://myanimelist.net/anime/9253/Steins_Gate">命运石之门系列 / Steins;Gate &amp; Zero</a></li><li><a href="https://myanimelist.net/anime/21/One_Piece">海贼王 / OnePiece</a></li></ul><h3 id="神作计划-1">神作计划</h3><h4 id="a-类">A 类</h4><ul><li><a href="https://myanimelist.net/anime/3701/Kaiba">海马 /Kaiba</a></li><li><ahref="https://myanimelist.net/anime/13125/Shinsekai_yori">来自新世界 /Shinsekai yori</a></li><li><ahref="https://myanimelist.net/anime/30/Neon_Genesis_Evangelion">新世纪福音战士/ Neon Genesis Evangelion</a></li><li><a href="https://myanimelist.net/anime/523/Tonari_no_Totoro">龙猫 /Tonari no Totoro</a></li><li><a href="https://myanimelist.net/anime/164/Mononoke_Hime">幽灵公主 /Mononoke Hime</a></li><li><ahref="https://myanimelist.net/anime/513/Tenkuu_no_Shiro_Laputa">天空之城/ Tenkuu no Shiro Laputa</a></li><li><a href="https://myanimelist.net/anime/437/Perfect_Blue">蓝色恐惧 /Perfect Blue</a></li><li><a href="https://myanimelist.net/anime/1943/Paprika">红辣椒 /Paprika</a></li><li><a href="https://myanimelist.net/anime/1033/Sennen_Joyuu">千年女优 /Sennen Joyuu</a></li><li><a href="https://myanimelist.net/anime/2471/Doraemon_1979">哆啦A梦系列 / Doraemon Series</a></li><li><a href="https://myanimelist.net/anime/223/Dragon_Ball?q=drag">龙珠系列 / Dragon Ball, Z &amp; GT</a></li><li><ahref="https://myanimelist.net/anime/1575/Code_Geass__Hangyaku_no_Lelouch">CodeGeass 反叛的鲁路修 系列 / Code Geass: Hangyaku no Lelouch &amp;R2</a></li></ul><h4 id="b-类">B 类</h4><ul><li><ahref="https://myanimelist.net/anime/82/Kidou_Senshi_Gundam_0080__Pocket_no_Naka_no_Sensou">机动战士高达0080口袋里的战争 / Kidou Senshi Gundam 0080: Pocket no Naka noSensou</a></li><li><ahref="https://myanimelist.net/anime/431/Howl_no_Ugoku_Shiro">哈尔的移动城堡/ Howl no Ugoku Shiro</a></li><li><ahref="https://myanimelist.net/anime/35857/Lupin_III__Part_5">鲁邦三世系列 / Lupin III Series</a></li><li><a href="https://myanimelist.net/anime/12189/Hyouka">氷菓 /Hyouka</a></li><li><ahref="https://myanimelist.net/anime/35120/Devilman__Crybaby">恶魔人crybaby / Devilman: Crybaby</a></li><li><ahref="https://myanimelist.net/anime/934/Higurashi_no_Naku_Koro_ni">寒蝉鸣泣之时系列 / Higurashi no Naku Koro ni</a></li><li><ahref="https://myanimelist.net/anime/512/Majo_no_Takkyuubin">魔女宅急便 /Majo no Takkyuubin</a></li><li><ahref="https://myanimelist.net/anime/199/Sen_to_Chihiro_no_Kamikakushi">千与千寻/ Sen to Chihiro no Kamikakushi</a></li><li><a href="https://myanimelist.net/anime/1535/Death_Note">死亡笔记 /Death Note</a></li><li><a href="https://myanimelist.net/anime/34599/Made_in_Abyss">来自深渊/ Made in Abyss</a></li><li><a href="https://myanimelist.net/anime/1462/Memories">大炮之街 /Cannon Fodder @ 回忆三部曲 / Memories</a></li><li><a href="https://myanimelist.net/anime/2182/Robot_Carnival">公主 /Presence @ 机器人嘉年华 / Robot Carnival</a></li><li><a href="https://myanimelist.net/anime/227/FLCL">特别的她 /FLCL</a></li><li><ahref="https://myanimelist.net/anime/2001/Tengen_Toppa_Gurren_Lagann">天元突破红莲螺岩/ Tengen Toppa Gurren Lagann</a></li><li><a href="https://myanimelist.net/anime/875/Mind_Game">心理游戏 /Mind Game</a></li><li><a href="https://myanimelist.net/anime/48849/Sonny_Boy">漂流男孩 /Sonny Boy</a></li><li><a href="https://myanimelist.net/anime/46102/Odd_Taxi">奇巧计程车 /Odd Taxi</a></li></ul><h4 id="c-类">C 类</h4><ul><li><ahref="https://myanimelist.net/anime/1303/The_Animatrix">黑客帝国动画版 /The Animatrix</a></li><li><ahref="https://myanimelist.net/anime/37451/Boogiepop_wa_Warawanai_2019">不吉波普不笑/ Boogiepop wa Warawanai</a></li><li><a href="https://myanimelist.net/anime/34542/Inuyashiki">犬屋敷 /Inuyashiki</a></li><li><ahref="https://myanimelist.net/anime/37779/Yakusoku_no_Neverland">约定的梦幻岛/ Yakusoku no Neverland</a></li><li><a href="https://myanimelist.net/anime/31580/Ajin">亚人 /Ajin</a></li><li><a href="https://myanimelist.net/anime/10793/Guilty_Crown">罪恶王冠/ Guilty Crown</a></li><li><ahref="https://myanimelist.net/anime/32962/Occultic_Nine">超自然9人组 /Occultic;Nine</a></li><li><a href="https://myanimelist.net/anime/39195/Beastars">动物狂想曲 /Beastars</a></li><li><a href="https://myanimelist.net/anime/565/Steamboy">蒸汽男孩 /Steamboy</a></li><li><a href="https://myanimelist.net/anime/522/Metropolis">大都会 /Metropolis</a></li><li><a href="https://myanimelist.net/anime/974/Dead_Leaves">落叶 / DeadLeaves</a></li><li><ahref="https://myanimelist.net/anime/237/Koukyoushihen_Eureka_Seven">交响诗篇/ Koukyoushihen Eureka Seven</a></li></ul><h3 id="伟大工匠-1">伟大工匠</h3><ul><li><a href="https://myanimelist.net/people/4580/Satoshi_Kon">今 敏 /Satoshi Kon</a></li><li><a href="https://myanimelist.net/people/1870/Hayao_Miyazaki">宫崎骏/ Hayao Miyazaki</a></li><li><ahref="https://myanimelist.net/people/1872/Katsuhiro_Otomo">大友克洋 /Katsuhiro Otomo</a></li><li><a href="https://myanimelist.net/people/5068/Masaaki_Yuasa">汤浅政明/ Masaaki Yuasa</a></li><li><ahref="https://myanimelist.net/people/2349/Hiroyuki_Imaishi">今石洋之 /Hiroyuki Imaishi</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对方舟编译器的简单调查</title>
      <link href="/report-on-ark-compiler/"/>
      <url>/report-on-ark-compiler/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要">1.摘要</h2><h3 id="背景">1.1.背景</h3><p>2019年4月11日，华为在P30系列手机发布会上正式宣布推出方舟编译器。8月31日，华为方舟编译器在华为开源平台上正式开源[1]。</p><p>在方舟编译器主页上，其被描述为"是为支持多种编程语言、多种芯片平台的联合编译、运行而设计的统一编程平台，包含编译器、工具链、运行时等关键部件"[2]。方舟编译器还在持续演进中，陆续将上述能力实现和开源。</p><h3 id="主旨">1.2.主旨</h3><p>本报告旨在搜集相关资讯、材料，整理相关内容，以对方舟编译器未来发展和其周边的可以做出进一步研究的方向进行合理推测和展望。从而可以给今后的科研选题做指导，并为下一步的调查做铺垫。</p><h2 id="架构">2.架构</h2><h3 id="整体结构">2.1.整体结构</h3><p><img src="/images/report-on-ark-compiler/image1.png" /></p><p>如上图，方舟编译器的宏观想法类似LLVM，会做出多种语言的前端（指编译器前端），实现从多种语言的代码翻译为IR（即 Maple IR），而后在中端（即 MapleME）实现各种语义处理、代码优化操作，最终生成二进制文件，其与编译器运行时库文件链接生成可执行文件。[3]</p><p><img src="/images/report-on-ark-compiler/image2.png" /></p><p>实现上大体如上图，我们以处理 Java代码为例（实际上目前的方舟编译器仅能处理 JAVA 或其他基于 JVM的语言的代码），首先代码通过某种方法翻译为 Java字节码（方舟编译器提供了一个脚本文件 java2jar 来做这件事），而后通过jbc2mpl（意为 Java Bytecode to MapleIR，是前端的实现，目前未开源）转换为 Maple IR，而后通过 mpl2mpl （意为Maple IR to Maple IR，用于处理语言特性）与 mplme （意为 Maple MiddleEnd，是中端的实现），这个阶段完成所有的静态分析和语义实现、优化操作。最后通过mplcg （意为 Maple CodeGenerator，是后端的实现，目前未开源）生成汇编代码，值得注意的是，目前的mplcg只支持arm64。[4]</p><p>在实际的操作过程中，由于文档不全面、开源不完整以及实现上的原因，会遇到各种各样的问题与错误。当然由于方舟编译器并不是传统意义上的开源项目，或是因为目前阶段开发者并未想过会有人实际使用项目，这些问题是可以接受的。</p><h3 id="phase-设计-5">2.2.Phase 设计 [5]</h3><p>方舟编译器使用 Phase 的形式组织每个优化操作。这个概念与 LLVM Pass类似，可以把每个 Pass视为一个模块，这些模块可单独工作，完成一个简单的任务；也可组合起来，共同完成一个较复杂的任务[6]。这使得整个Maple中端的灵活性和模块化程度较高。</p><p>在实现上，每个 Phase 都需要重写 run 方法，这类似于 LLVM Pass 的runOn... 系列方法。中端主要包含两大类 Phase，分别为maple_ipa（意为MapleInterprocedural Analysis）里的ModulePhase和maple_me（意为 Maple MiddleEnd，编译出的可执行文件即上文中的mplme）里的MeFuncPhase（意为 Middle EndFunction Phase） [5]。具体实现出的 Phase 如下图。 [7] [8]</p><p><img src="/images/report-on-ark-compiler/image4.png" /></p><p>方舟编译器设计了PhaseManager负责Phase的创建、管理和运行。ModulePhase和MeFuncPhase都有对应的Manager类，即ModulePhaseManager和MeFuncPhaseManager。而PhaseManager类主要是通过InterleavedManager和DriverRunner来创建、管理和运行。可以看出这是一个三层管理体制。</p><h3 id="ir-设计-9">2.3.IR 设计 [9]</h3><p>Maple IR 是一个高阶的（high level） IR，这是和 LLVM IR最大的不同之处。所以其被设计成了hierarchical IR，有许多与语言特性相关的opcode 以及 if、while等在低阶IR中不可能见到的节点，也会尽最大可能的去保持源程序信息的完整性，以服务于程序的分析和优化。</p><p>Maple IR与平台无关，是一个面向由多种编程语言编译来的程序的共同表示，在支持新语言时可能会加入新的opcode，既可以保留某个语言中特定的语义，而不直接向下翻译成更低阶的表示。</p><p>其设计不由让人联想到 Whirl IR 的设计。WhirlIR把IR分为了多种不同的level，具有从高级语言到底层机器码的过程中的所有可能需要的不同level的表示形式，可以方便进行不同层级的优化。[10]</p><p>在IR设计文档中有说明，中端在处理中会不断将hierarchicalIR的树形结构进行拍平，并且抹除语言特有的opcode，将直接表示出的语义翻译为更低阶的表示形式，最终达到一种类似 flatIR 的低阶的（low level）IR。但目前并未在代码中找到 Maple IR如何记录高低阶的变化如何变为低阶 IR。</p><p>Maple IR 基本类型的设计也体现了其作为高阶IR的考量，如图所示，其中的ptr, ref, SIMD types 以及 javascript types 体现了这一点。</p><p><img src="/images/report-on-ark-compiler/image5.png" /></p><h3 id="gc设计">2.4.GC设计</h3><p>Java 使用GC管理、回收内存，主流的 Java VM实现都没有采用引用计数（RC）的方法而一般采用Tracing GC[11]，但方舟编译器采用了朴素的（naive）RC[12]，并配合一些静态检测以解决循环引用的问题，暂不清楚如何解决频繁更新引用计数所导致的效率损失问题。</p><p>由于目前无法实际使用方舟编译器编译项目，我们无法得知这种改动会对运行效率产生怎样的影响，在方舟编译器可以投入使用后才可以观测到具体数据。</p><p>在上文中提到，Maple 中端中会有一些MeFuncPhase，其中一个Phase即MeDoRCLowering就是用于在对象创建、销毁时插入引用计数操作，以实现RC语义。通过这个Phase，方舟编译器完成了对于 Java 对象的内存管理操作的语义实现。</p><h2 id="现状">3.现状</h2><h3 id="开源情况">3.1.开源情况</h3><p><img src="/images/report-on-ark-compiler/image6.png" /></p><p>方舟编译器并不是一个传统的开源项目，其提出了按期开源的策略，分阶段地开源，每次只开源一部分代码。如图所示，目前开源的部分包括M2M（MapleIR to Maple IR）的全部代码，以及中端（Maple MiddleEnd）的部分代码，其中主要包括 SSA生成和RC、虚函数表语义的实现。 [13]</p><p>而编译器前、后端，Java的需要在中端实现的许多其他语义如annotation、lambda表达式、泛型等以及一些静态分析和优化，Javascript等其他语言的编译在本期并未被开源。另外本次开源包括了Driver，即整个流程的管理框架，具体来说是InterleavedManager和DriverRunner，当然我认为也包括各种PhaseManager。</p><p>具体到代码上，目前的mpl2mpl 和 mplme部分的开源代码包括maple_driver、maple_ipa、maple_ir、maple_me、mpl2mpl（描述如下表）已经可以足够支撑其构建出中端的可执行文件，而其他可执行文件皆直接被放在src/bin目录中，未提供源代码。</p><table><colgroup><col style="width: 67%" /><col style="width: 32%" /></colgroup><thead><tr class="header"><th>目录名（在 src/ 下）</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>mpl_phase</td><td>Phase基本框架的代码（只有头文件和库文件，未开源）</td></tr><tr class="even"><td>maple_driver</td><td>包含了驱动整个流程运行的代码，也是程序的入口点</td></tr><tr class="odd"><td>maple_ipa</td><td>InterleavedManager和ModulePhaseManager的相关代码</td></tr><tr class="even"><td>maple_ir</td><td>针对Maple IR的基本操作的相关代码</td></tr><tr class="odd"><td>maple_me</td><td>有关MeFuncPhase类别的Phase的框架及其具体内容</td></tr><tr class="even"><td>mpl2mpl</td><td>一些从Maple IR到Maple IR的转换，为后续的ME做准备</td></tr></tbody></table><h3 id="代码质量">3.2.代码质量</h3><p>在方舟编译器开源之初，其代码质量曾引起广泛的讨论。可以看到其中一些代码并未遵循其文档中的代码规范，以及一些明显错误的C++用法，被知乎用户在社区中指出。[14]</p><p>但华为使用了Coverity作为静态分析工具，其代码质量是有一定保证的。源伞科技曾使用其商业级静态分析器Pinpoint扫描其最新代码（13e1bc6），发现了一些潜在的Bug，但得到了整体代码质量良好的结论。[15]</p><h2 id="展望">4.展望</h2><p>虽然国际上有许多成熟、优秀的编译器项目（如LLVM等），以及一些正在开发的IR（如MLIR等），并且这些项目都有国人参与，但方舟编译器确实代表了国内公司的研发水平。</p><p>在接下来的开源计划中，方舟编译器把前端、后端、编译优化，完整支持Java程序编译、JavaScript语言应用的编译提上了日程。在实现这些开源计划后，方舟编译器才会走出孵化期，成为一个正常意义上的、健壮的开源项目。[16]</p><p>在项目的README中，开发者总结了四个技术特点，指出方舟编译器能够将不同语言代码编译成一套可执行文件，在运行环境中高效执行：[16]</p><ul><li>支持多语言联合优化、消除跨语言调用开销；</li><li>更轻量的语言运行时；</li><li>软硬协同充分发挥硬件能效；</li><li>支持多样化的终端设备平台。</li></ul><p>当然，这都是在完成孵化期后才能看到的效果。</p><h2 id="对比">5.对比</h2><h3 id="llvm">5.1.LLVM</h3><p>上文中已经提及了部分与 LLVM的对比，包括Phase、IR的特点上的比较。LLVM作为至今为止最成熟、使用最广泛的编译器项目，有许多设计上的优点值得被借鉴。</p><p>值得注意的是，Maple IR与LLVM IR在目的上有着本质的区别，LLVM IR作为一种底层IR不需要任何语言特性相关的 opcode，这使得LLVMIR在设计上（传统的基于CFG的三地址SSA表示形式）较为整洁，且成熟稳定。MapleIR作为上层IR会在支持新的语言时做较多改动，且需要较多的特定语言相关的表达。</p><p>MAPLE IR是采用的是类似C语言的形式，将IR分为声明语句（declarationstatements）和执行语句（executablestatements）两部分，前者表达符号表信息，后者表达要执行的具体程序代码。而LLVMIR当然更类似于汇编的形式。</p><p>在整体结构上，二者都有module这个概念，而且其内涵也是一致的，都是对应着一个CU（CompilationUnit，编译单元）。在module之下都是一些全局的声明和函数声明，这部分是一个module的主要内容。CU内的结构如图所示：[9]</p><p><img src="/images/report-on-ark-compiler/image7.png" /></p><p>而LLVM的整体结构的布局可以用如下图片表示： [17]</p><p><img src="/images/report-on-ark-compiler/image8.png" /></p><p>可以看到虽然有许多差别，但是基本的结构并没有非常大的不同。Maple IR在处理的过程中也会不断的进行层次下降操作，最终应该被规约为与底层的IR相类似的结构。</p><h3 id="open64-10">5.2.Open64 [10]</h3><p>如果说 LLVM 与 Maple在IR上有出发点的不同，那么用Open64做对比能从更近距离的角度观察MapleIR。因为Open64的Whirl IR与Maple IR 在设计思路上更加接近。</p><p>在WhirlIR中，IR被分为了多种不同的level，包括从高级语言到底层机器码的过程中的所有可能需要的不同level的表示形式，可以方便进行不同层级的优化。highlevel的IR可以进行和语言特性相关的优化，lowlevel进行和硬件特性相关的优化。在其设计文档中可以找到IR处理过程的流程图。</p><p><img src="/images/report-on-ark-compiler/image9.png" /></p><p>如图，每一个转换过程都会将更high level的IR翻译为lowerlevel的IR。这与我们之前对MapleIR一致。举一个简单的例子，像if、while这种highlevel、层级化的控制流opcode，经过Phase的转换、优化后，应该会变成goto、brfalse、brtrue等扁平化的控制流opcode。当然，MAPLEIR虽然也称自己为多层IR，但是缺乏类似的文档和代码展示其多层IR的具体情况和对应关系。</p><p>和Whirl IR不太一样的地方，就是MapleIR中有一些直接和前端语言特性强相关的opcode，比如Javascript的数据类型、opcode中的JavaCall以及Java Class and Interface Declaration等。这个做法是否会引起 IR的复杂性随前端语言增多而暴增是一个值得讨论的问题。</p><h3 id="robovm">5.3.RoboVM</h3><p>RoboVM是一个将 Java Bytecode 编译为 LLVM IR的项目，有趣的是其前端使用了Soot来做静态分析以帮助转换工作，其做的工作与目前的MapleIR在某种程度上是类似的，遗憾的是其原本的开发者已经抛弃了这个项目，目前由MobiVM维护着一个fork（指fork 了原 Git repo）。 [18]</p><p>Maple 与 RoboVM最大的不同点其实与LLVM IR与MapleIR的不同点是一致的，都是IR的出发点不同的区别。RoboVM可以在宏观意义上认为是LLVM的一个前端，其工作量小于方舟编译器。</p><p>在Maple IR的设计文档中提到，其有配套的Maple VM，Maple IR可以作为MapleVM的输入，在MapleVM上执行，而不需要进一步翻译成针对某个目标处理器的机器指令。这其实比RoboVM更接近JVM的工作。</p><h3 id="mlir">5.4.MLIR</h3><p>LLVM的作者Chris Lattner 加入GoogleBrain之后为Tensorflow提出了名为MLIR（Multi-LevelIR）的项目，其接受多种语言作为输入，而将LLVM IR作为输出。这一想法与MapleIR在IR分层上不谋而合。 [19]</p><p>在一次演讲（EuroLLVM Developers' Meeting）中，指出了一个比 LLVM IR更高阶的IR所带来的好处，并声称Clang需要一个更高阶的IR（称之为CILIR）以更好地进行静态分析工作，就像 Rust在MIR中完成borrowchecker的所有分析工作那样。 [20]</p><p>其在演讲幻灯片中用图片展示了这一概念：</p><p><img src="/images/report-on-ark-compiler/image10.png" /></p><p>当然，与MLIR不同的是，方舟编译器打算自己完成后端，而不是借助LLVM，这使得Maple的工作量和需要的时间更多。</p><h2 id="值得参与的方向">6.值得参与的方向</h2><h3 id="对方舟编译器的形式验证">6.1.对方舟编译器的形式验证</h3><p>CompCert作为使用形式验证技术构建出的可为PowerPC，ARM，RISC-V和x86处理器生成高效代码的C语言（C99）编译器在众多测试面前屹立不倒，证明了使用形式验证保证编译器可信的可行性。</p><p>方舟编译器虽然使用C++（指 C++14）实现，但采用了模块化程度较高的Phase模式，很容易从中拿出某个Phase进行验证而不需要担心其他方面的影响，比如可以对DoRCLowering这个Phase进行验证，以确保实现了正确的RC语义。</p><h3 id="对maple-ir的静态分析">6.2.对Maple IR的静态分析</h3><p>LLVM/Clang拥有ClangStaticAnalysis和clang-tidy两大静态分析引擎，可以胜任对C/C++代码的各种分析工作，如符号分析等。</p><p>MapleIR在理论上更有优势，因为ClangStaticAnalysis在AST层面分析会遇到许多冗余信息，从而做更多的判断，而在高阶IR层面可以在减少不必要的冗余信息的基础上保留静态分析所需要的全部信息，从而使得静态分析工作被简化。</p><p>目前Maple IR的静态分析工作非常不完备，故可以从这里着手参与MapleIR的工作。</p><h3 id="maple-ir-到llvm-ir的转换">6.3.Maple IR 到LLVM IR的转换</h3><p>目前未开源的 mplcg 仅支持从MapleIR生成arm64机器代码，但如果可以直接生成LLVM IR，则可以支持多种架构，使得MapleIR的应用范围扩大，且可以利用起LLVM，使得后端的稳定性极大的增强。</p><h3 id="对分层次ir的研究">6.4.对分层次IR的研究</h3><p>从Whirl IR，到MapleIR和MLIR，分层次IR比起传统的单层或是底层IR有着许多优势，而如何更好的设计分层次IR成为了一个引人注目的问题。系统地研究分层次IR可能会得到更好的结果以推动工业级IR的设计。</p><h2 id="附录">7.附录</h2><h3 id="引用">7.1.引用</h3><p>[1] CNMO, "华为正式宣布 方舟编译器将于8月31日正式开源," 2019. [联机].Available:https://tech.sina.com.cn/mobile/n/n/2019-08-30/doc-iicezzrq2140953.shtml.</p><p>[2] 华为, "方舟编译器 官方网站," 华为, 2019. [联机]. Available:https://www.openarkcompiler.cn/.</p><p>[3] 华为, "方舟编译器 架构设计," 2019. [联机]. Available:https://www.openarkcompiler.cn/document/frameworkDesgin.</p><p>[4] 华为, "方舟编译器 开源代码 官方主仓库," 2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler.</p><p>[5] 华为, "方舟编译器 Phase 设计介绍," 2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/doc/Compiler_Phase_Description.md.</p><p>[6] LLVM, "Writing an LLVM Pass - LLVM 10 documentation," [联机].Available: http://llvm.org/docs/WritingAnLLVMPass.html.</p><p>[7] 华为, "方舟编译器 开源代码src/maple_ipa/include/module_phases.def," 2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_ipa/include/module_phases.def.</p><p>[8] 华为, "方舟编译器 开源代码 src/maple_me/include/me_phases.def,"2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/src/maple_me/include/me_phases.def.</p><p>[9] 华为, "Maple IR Design Document," 2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/doc/MapleIRDesign.md.</p><p>[10] Open64, "Open64 Compiler Whirl Intermediate Representation," 3 82007. [联机]. Available: https://www.mcs.anl.gov/OpenAD/open64A.pdf.</p><p>[11] RednaxelaFX,"垃圾回收机制中，引用计数法是如何维护所有对象引用的？," [联机].Available: https://www.zhihu.com/question/21539353/answer/18596488.</p><p>[12] 华为, "朴素版 RC 操作插入原理," 2018. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/doc/Naive_RC_Insertion_Description.md.</p><p>[13] 华为, "方舟编译器 官方网站 FAQ," 2019. [联机]. Available:https://www.openarkcompiler.cn/document/FAQ.</p><p>[14] bsdelf, "程序员们如何看待华为方舟编译器首次开源部分代码？,"2019. [联机]. Available:https://www.zhihu.com/question/343494051/answer/809494133.</p><p>[15] 源伞科技, "华为方舟的爱之体检," 2019. [联机]. Available:https://www.sourcebrella.com/blog/huawei-ark-compiler-test/.</p><p>[16] 华为, "方舟编译器 开源代码 Readme.md," 2019. [联机]. Available:https://gitee.com/harmonyos/OpenArkCompiler/blob/master/Readme.md.</p><p>[17] V. Bridgers, "LLVM IR Tutorial - Phis, geps and other things, ohmy!," [联机]. Available:http://llvm.org/devmtg/2019-04/slides/Tutorial-Bridgers-LLVM_IR_tutorial.pdf.</p><p>[18] MobiVM, "MobiDevelop's RoboVM Fork," [联机]. Available:http://robovm.mobidevelop.com/.</p><p>[19] Google, "Multi-Level Intermediate Representation - GitHub Repo,"2019. [联机]. Available: https://github.com/tensorflow/mlir.</p><p>[20] T. Shpeisman 和 C. Lattner, "MLIR: Multi-Level IntermediateRepresentation for Compiler Infrastructure," 2019. [联机]. Available:https://ai.google/research/pubs/pub48035.pdf.</p>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> huawei </tag>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给 clang-tidy 写新 checker</title>
      <link href="/write-new-checker-for-clang-tidy/"/>
      <url>/write-new-checker-for-clang-tidy/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="/images/write-new-checker-for-clang-tidy/clang-tidy-in-clion.png"alt="clang-tidy-in-clion" /><figcaption aria-hidden="true">clang-tidy-in-clion</figcaption></figure><h2 id="clang-tidy-里的-checker-起着着怎样的作用">clang-tidy 里的checker 起着着怎样的作用</h2><p>clang-tidy 作为 c++ 中少数几个能用的lint，广泛用于代码静态分析以检测问题。</p><p>把 clang-tidy clone 到本地后，你会发现每个文件夹都有一组checker，而其中每个 <code>.cpp</code> 文件（以及对应的头文件）都是一个checker，结构出奇的简单。</p><p>每个 checker 都是针对某一特定问题的的检测器，如 <ahref="https://github.com/isocpp/CppCoreGuidelines">CppCoreGuidelines</a>是标准委员会提出的一些“最佳实践”，我们也可以称之为“规范”或者“约束”。而clang-tidy 实现了对于每一个“规范”项的检查，如<code>CppCoreGuidelines/AvoidGotoCheck</code> 实现了对于 <ahref="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es76-avoid-goto">ES.76:Avoid goto</a> 的检查。</p><p>我们可以做个小试验： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop: std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行 clang-tidy 以检测文件（设以上代码保存到 test.cpp）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">clang-tidy --checks=<span class="string">&quot;cppcoreguidelines-avoid-goto&quot;</span> test.cpp --</span></span><br></pre></td></tr></table></figure></p><p>很多人会好奇为什么语句的末尾有<code>--</code>，所以我决定不做解释。我们发现有类似以下的输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 warning generated.</span><br><span class="line">test.cpp:5:2: warning: avoid using &#x27;goto&#x27; for flow control [cppcoreguidelines-avoid-goto]</span><br><span class="line">        goto loop;</span><br><span class="line">        ^</span><br><span class="line">test.cpp:4:2: note: label defined here</span><br><span class="line">        loop: f();</span><br><span class="line">        ^</span><br></pre></td></tr></table></figure></p><p>clang-tidy 检测出了 <code>goto</code>语句处和与之对应的标签的定义处。</p><p>不过我相信很多人会抱怨这个检查太 trivial，下面我们会写较复杂的checker 以体验 clang-tidy 借助于强大的 LLVM/clang 而具有的无穷威力。</p><h2 id="开始行动">开始行动</h2><p>首先，本篇文章并不包含环境的搭建、代码的详细解读、API的说明，也并不给出源代码。其次，我假设读者熟悉 C++（<code>std&gt;=11</code>）；编译器前端的知识，包括 parser等；以及软件工程知识，如 visitor pattern。</p><p>clang-tidy 提供了一个名为 <code>add_new_check</code> 的脚本文件（用Python 编写），用以快速生成新的 checker，我们可以借助他来init。之后我真诚地推荐读者先 cmake出平台特定的可构建项目后构建整个项目，在这个过程中你可以选择看个电影、陪妹子吃顿饭、唱K，总之请不要把时光葬送在盯着进度条看上。</p><h3 id="matcher函数式与编译错误">matcher：函数式与编译错误</h3><p>LibASTMatchers 是 clang 提供的一种 DSL（之所以称之为 DSL是因为其与正常的执行逻辑不同），以谓词的方式给出对节点的约束，以找到符合约束的节点。</p><p>写起来有种 SQL 的查询语句一样的感觉（或是其他 querylanguage），有种函数式的手感。但众所周知，这个库用的一些算不上奇技淫巧的“技巧”来完成，所以如果不慎用错函数，编译错误信息简直难以看懂，哦不，根本看不懂。不过没到元编程的那种境界，如果你比较熟悉C++，找到错误还是不难的（盲猜）。</p><p>对于比较简单的，不含递归的检查，我们可以使用 matcher很轻易的完成，这是 matcher 最大的优点。reference上有个不错的例子（我做了修改）： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">recordDecl(hasDescendant(</span><br><span class="line">    ifStmt(hasThen(</span><br><span class="line">        stmt(hasDescendant(</span><br><span class="line">            ifStmt()))))))</span><br></pre></td></tr></table></figure></p><p>我们可以调出 query language 那种特定的脑回路来读这段代码：有一个<code>recordDecl</code>（记录声明，在 c++ 里可以看作<code>struct</code>/<code>class</code>），它有这样的后代（即 AST 上这个<code>recordDecl</code> 节点的后代节点），which is 一个<code>ifStmt</code>，这个 <code>ifStmt</code> 的 true 分支语句中有后代为<code>ifStmt</code>，整体来说非常易懂且简洁。</p><p>我们会发现库中提供了三类匹配器：</p><ul><li>Node Matchers: 匹配某个类型的节点，如上面的<code>recordDecl</code>、<code>ifStmt</code></li><li>Narrowing Matchers:匹配节点的某种属性，上面的语句中没有出现，但这一类应该最容易理解，如描述某个<code>CXXMethodDecl</code> 是否被 const 修饰的 <code>isConst</code></li><li>Traversal Matchers: 遍历匹配器，用来描述节点间关系，如上面的<code>hasDescendant</code>、<code>hasThen</code></li></ul><p>那么我们怎么表达逻辑稍微复杂点的匹配查询呢，我们需要一些可以组合的、通用的谓词：</p><ul><li><code>all</code>: 描述某些谓词全部成立</li><li><code>any</code>: 描述某些谓词至少有一个成立</li><li><code>anything</code>: 这个谓词始终成立</li><li><code>unless</code>: 描述某个谓词不成立，类似于取非</li></ul><p>还有一些比较通用的谓词，如 <code>forEach</code>, <code>has</code>等，顾名思义，请查看文档。</p><p>掌握了这些知识，我们就可以根据文档做一些练习，如：</p><ul><li>写一个检测 <code>sizeof</code> 是否只作用于变量或是类型的matcher</li><li>（选做）并在诊断信息中输出 <code>sizeof</code>中的表达式及其类型</li></ul><h3 id="visitor真香">visitor：真香</h3><p>当遇到非常复杂的逻辑时，一个 matcher 可能很难或是无法完成任务，多个matcher 或许很复杂或是也无法完成任务，我们可以配合使用 visitor来完成。</p><p>我们只介绍 <code>StmtVisitor</code>，顾名思义它可以遍历 AST 中的<code>Stmt</code> 节点，我们需要知道的是在 clang 里 <code>Expr</code>继承了 <code>Stmt</code>，所以我们可以用它访问语句和表达式。</p><p>构建一个可以 work 的 vistor 很简单，我们只需要继承<code>StmtVistor</code>，然后重写 <code>VisitStmt</code> 以遍历每个<code>Stmt</code> 节点的所有子节点，如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VisitStmt</span><span class="params">(Stmt *stmt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> *child : stmt-&gt;<span class="built_in">children</span>()) &#123;</span><br><span class="line">    <span class="built_in">Visit</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以访问到全部的节点，然后我们可以根据需要重写其他的方法，以完成特定的任务，如重写<code>VisitCXXMemberCallExpr</code> 以在访问到<code>CXXMemberCallExpr</code> 时做一些事情。</p><p>好了，让我们开始练习：</p><ul><li>实现针对《Effective C++》中第九条“在析构/构造时不要调用虚函数”的检测器</li><li>（选做）输出时请指明在 ctor/dtor中哪一个调用涉及了虚函数，如果这个调用本身不是虚函数，那么请指出这个调用中在那个地方调用了虚函数</li></ul><p>思路提示：当然是 DFS 啦</p><p>（答案可来信索取，自己完成或许更有成就感）</p><h2 id="引用">引用</h2><ol type="1"><li><a href="https://clang.llvm.org/extra/clang-tidy/">Clang-Tidy -Clang documentation</a></li><li><a href="https://clang.llvm.org/docs/LibASTMatchers.html">Matchingthe Clang AST - Clang documentation</a></li><li><ahref="https://clang.llvm.org/doxygen/classclang_1_1StmtVisitor.html">clang::StmtVisitor&lt;ImplClass,RetTy, ParamTys&gt; Class Template Reference</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> AST </tag>
            
            <tag> program analysis </tag>
            
            <tag> clang </tag>
            
            <tag> llvm </tag>
            
            <tag> clang-tidy </tag>
            
            <tag> checker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 需要反射吗</title>
      <link href="/does-cpp-need-reflection/"/>
      <url>/does-cpp-need-reflection/</url>
      
        <content type="html"><![CDATA[<h2 id="注意">注意</h2><p><img src="/images/zhihu/zhihu.jpg" alt="zhihu.jpg" />本文旨在整理知乎上的回答，原答案链接请<ahref="https://www.zhihu.com/question/268188946/answer/334037634">戳这里</a>。</p><h2 id="c-需要静态编译期反射">C++ 需要静态（编译期）反射</h2><p>并且 WG21 正在为这一点而努力。具体请看 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2019/n4818.pdf">N4818</a>（ReflectionTS），以及可以吊打 N4818 的 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2019/p1717r0.pdf">P1717</a>（extendedP0712，最近很长时间没关注了，难道 Andrew Sutton 不想跟 Herb Sutter一起玩儿了？），让我们感受一下里面的第一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span> &#123;</span><br><span class="line">    <span class="keyword">consteval</span> &#123;</span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>... (meta::info type : <span class="built_in">reflexpr</span>(Types)) &#123;</span><br><span class="line">            <span class="keyword">auto</span> fragment = __fragment <span class="keyword">struct</span> &#123;</span><br><span class="line">                <span class="built_in">typename</span>(type) <span class="built_in">unqualid</span>(<span class="string">&quot;element_&quot;</span>, counter);</span><br><span class="line">            &#125;;</span><br><span class="line">            -&gt; fragment;</span><br><span class="line">            ++counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="type">bool</span>, <span class="type">char</span>, <span class="type">int</span>&gt; tup;</span><br></pre></td></tr></table></figure><p>在 tuple 被特化时大概将生成以下的代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span> &#123;</span><br><span class="line">    <span class="type">bool</span> element0;</span><br><span class="line">    <span class="type">char</span> element1;</span><br><span class="line">    <span class="type">int</span> element2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>完全可以吊打传统的 tuple实现方式（当然这只是个很不完备的小例子），包括恐怖的递归继承实现方式和比前者好一点的多继承实现方式。实际上我认为这可以一定程度上使得C++远离许多奇技淫巧，可以让大家免于记忆一大堆由于语言设施不完备做出妥协而流传于世的idioms 的痛苦。</p><h2 id="c-标准不需要动态运行期反射">C++标准不需要动态（运行期）反射</h2><p>或者说，我认为一旦有了静态反射，动态反射就完全可以由社区提供，比如 <ahref="https://github.com/rttrorg/rttr">RTTR</a>，当然我更倾向于认为大部分需求都能用静态反射解决。</p><p>所有说可以用 C++宏实现反射的人都是不负责任，宏的部分功能应该被静态反射淘汰，这种极其落后的语言设施应该被消灭掉。</p>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ standard </tag>
            
            <tag> reflection </tag>
            
            <tag> c++ template </tag>
            
            <tag> zhihu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 秋季漫谈</title>
      <link href="/cpp-fall-talk/"/>
      <url>/cpp-fall-talk/</url>
      
        <content type="html"><![CDATA[<figure><img src="/images/cpp-fall-talk/cpp-error.jpg" alt="cpp-error" /><figcaption aria-hidden="true">cpp-error</figcaption></figure><h2 id="序">序</h2><p>十月中旬<span class="math inline">\(^1\)</span>，WG21<spanclass="math inline">\(^2\)</span>公开了整理出的十月份提案列表，很长。</p><p>委员会各种会议如火如荼，C++ 却已近秋。</p><p>Bjarne Stroustrup 在三月份写过题为 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0977r0.pdf"><em>Rememberthe Vasa!</em></a> 的短文，提出了一个非常重要的忧虑 —— C++是否能够继续以目前的形式扩充。</p><p>这篇短文引出了一个现实，所有这些提案没有一个一致、可共享的目标。每个人分散地提出自己认为可行地修改，而所有人一起这样做就可能导致Vasa<span class="math inline">\(^3\)</span> 式结果。</p><h2 id="上">上</h2><p>事到如今确实只能修补，但修补不是糊墙。</p><p>一个有趣的问题是，C++ 的优势是什么？</p><ul><li>直接编译到机器码，没有中间语言、没有GC，适合性能需求高的场合或是搭建底层、接近硬件的系统</li><li>历史积淀深厚，有着一大堆各领域性能需求高的项目支撑，且在很大程度上完全兼容C 或易于将 C 项目迁移到 C++编译环境；在大多数操作系统中都有相应的编译套件</li><li>较强大的静态类型系统，除了没有 sum type<spanclass="math inline">\(^4\)</span> 之外，其他方面的表现是强劲的，尤其是C++11 及之后的标准，甚至部分标准库部件（如<code>std::chrono</code>）以富类型的方式 ( type rich style ) 架构</li><li>支持多种范式而没有做太多约束，甚至最近加入了 contract basedprogramming<spanclass="math inline">\(^5\)</span>，你可以用你自己喜欢的想法架构你的代码，唯一的缺点是，忍受略蹩脚的文法</li></ul><p>那么 c++ 到底需要什么？</p><h2 id="中">中</h2><p>关于这个问题 SG15<span class="math inline">\(^6\)</span>最有发言权，十月份提案中有另一篇标题相似的短文 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1300r0.pdf"><em>Rememberthe FORTRAN</em></a>，指出了 Modules TS<spanclass="math inline">\(^7\)</span> 在编译环境的核心问题。</p><p>当我们回顾 C++ 的工具链演变史，对比其他语言，我们可以很轻易地发现 ——C++ 在语言上缺乏模块系统，以及基于模块的依赖管理工具及其他工具。当 C++从 C 中继承了蠢萌的预处理器引入其他文件的机制时，已经存在的 Ada、ML等语言早已有了模块系统。</p><p>甚至于说，C++ 在符号链接等方面的麻烦，要由 <code>#include</code>等直接负责。甚至在 Modules TS 的设计时，由于要考虑到<code>#include</code> 等预处理指令，也变得麻烦。</p><p>委员会部分成员最近致力于 <em>constexpreverywhere</em>，甚至希望将语言中的 <code>new</code>以及周边标准作修改以适用于 <code>constexpr</code> <spanclass="math inline">\(^{8}\)</span>，以做到在编译期使用标准容器，如<code>std::vector</code>。</p><p>当然这就引出一个巨大的问题 —— C++ 没有编译时反射。Reflection TS由此而生，但设计的并不怎么样，甚至于 Function Reflection这种最基本的东西都是后来补进去的<spanclass="math inline">\(^{9}\)</span>。C++太过于复杂以至于很难设计出完整的反射。</p><p>唯一值得探讨的我认为是 Herb Sutter 提出的Metaclasses。当然这里重点并不是 Metaclasses 本身，而是跟随 Metaclasses一起提出的、用作 Metaclasses 的基础设施支撑的一个提案<spanclass="math inline">\(^{10}\)</span>，其中的 <code>constexpr</code>block、<code>for...</code> statement、<code>declname</code>以及并不基于模板的反射 API 都是非常棒的主意，可惜我认为近期<spanclass="math inline">\(^{11}\)</span>难以并入标准。</p><p>纵观目前活跃的提案，已经并入 C++20 的 部分Concepts TS<spanclass="math inline">\(^{12}\)</span>，以及 Contract<spanclass="math inline">\(^5\)</span> 都并不能给 C++带来决定性的变化，事实上甚至有不少质疑<spanclass="math inline">\(^{13}\)</span>，不过基于 Concepts 的 Ranges TS以及众望所归的 Coroutines TS 被期冀有望<spanclass="math inline">\(^{14}\)</span>并入 C++20 确实是个好消息。</p><p>但是由于 Executor 未并入标准（甚至未作为 TS）<spanclass="math inline">\(^{15}\)</span>，许多基于它的设施不可能完整地在它之前并入标准。这其中包括了Networking TS，当然值得一提的是 Networking 的主要部分并不依赖于Executor<span class="math inline">\(^{16}\)</span>。</p><h2 id="下">下</h2><p>所有的这些都在传达着一个消息 —— C++ 身上的历史包袱重地令人叹惋，而D、Rust 等（抱歉没有Go）语言以重新设计的轻盈洁净的文法、语义试图创造一种更优雅地高性能编程环境。</p><p>如果 Modules 可以在近期并入标准，我大概还会吹 C++。</p><h3 id="年-2月补充">2019 年 2月补充</h3><p>综合 Toronto, Rapperswil, San Diego, Kona meeting 的结果， Modules,Ranges, Coroutines, Concepts, Contracts 都已经并入 C++20。</p><h3 id="年-7月补充">2019 年 7月补充</h3><p>在 Cologne meeting 上，Contracts 被移出 C++20。</p><h2 id="注">注</h2><p><span class="math inline">\([0]\)</span> 封面图来自于刘雨培的文章 <ahref="https://zhuanlan.zhihu.com/p/24328534">为什么不再想碰 C++</a></p><p><span class="math inline">\([1]\)</span> 具体为 2018 年 10 月 13日</p><p><span class="math inline">\([2]\)</span> 指 JTC1/SC22/WG21，The C++Standards Committee</p><p><span class="math inline">\([3]\)</span> <ahref="https://en.wikipedia.org/wiki/Vasa_(ship)">瓦萨号</a>，是瑞典国王古斯塔夫二世下令建造的一艘军舰</p><p><span class="math inline">\([4]\)</span> 通俗上称为 <ahref="https://en.wikipedia.org/wiki/Tagged_union">taggedunion</a>，实际上 c++ 有这类提案，例如 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0095r2.html">P0095</a></p><p><span class="math inline">\([5]\)</span> <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0542r4.html">P0542</a>,Support for contract based programming in C++ （已并入 c++20）</p><p><span class="math inline">\([6]\)</span> 指 JTC1/SC22/WG21/SG15</p><p><span class="math inline">\([7]\)</span> 这里泛指 Modules TS以及之后的 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1103r1.pdf">MergingModules</a>，下同</p><p><span class="math inline">\([8]\)</span> <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0784r1.html">P0784</a>,Standard containers and constexpr</p><p><span class="math inline">\([9]\)</span> <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0670r4.html">P0670</a>,Function reflection</p><p><span class="math inline">\([10]\)</span> <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0712r0.pdf">P0712</a>,Implementing language support for compile-time metaprogramming</p><p><span class="math inline">\([11]\)</span> 在 C++标准化的尺度上，我认为 3-6 年可以算作近期</p><p><span class="math inline">\([12]\)</span> <ahref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4674.pdf">N4674</a>,Working Draft, C++ extensions for Concepts</p><p><span class="math inline">\([13]\)</span> 如对 Concepts TS 的质疑 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0726r0.html">P0726</a></p><p><span class="math inline">\([14]\)</span> 见 <ahref="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil">Tripreport: Summer ISO C++ standards meeting (Rapperswil)</a> 中的<em>Whats's Next</em> 小节</p><p><span class="math inline">\([15]\)</span> <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1256r0.html">P1256</a>建议将其作为 TS 处理</p><p><span class="math inline">\([16]\)</span> 由此 <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1259r0.html">P1259</a>建议并入不依赖于 Executor 的那部分</p>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ standard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过往演讲及分享的整理与资料公开</title>
      <link href="/information-of-past-presentations/"/>
      <url>/information-of-past-presentations/</url>
      
        <content type="html"><![CDATA[<figure><img src="/images/information-of-past-presentations/talk.gif"alt="talk" /><figcaption aria-hidden="true">talk</figcaption></figure><h2 id="年-11月">2017年 11月</h2><p><strong>泛型与 <spanclass="math inline">\(STL\)</span></strong>，本科 C++ 程序设计 演讲</p><p>获取 PPT： 参考 <span class="math inline">\([1]\)</span></p><h2 id="年-6月">2018年 6月</h2><p><strong>泛型与 <span class="math inline">\(STL\)</span></strong>，校ACM 集训队 演讲</p><p>获取 PPT： <ahref="https://1drv.ms/b/s!AqRWJ64OmjGTl1A4J1gUu_SJYYZ9">OneDrive,PDF</a><span class="math inline">\(^1\)</span></p><h2 id="年-10月">2018年 10月</h2><p><strong><span class="math inline">\(Haskell\)</span>与纯函数式编程语言</strong>，信息学院科技创新协会 分享</p><p>获取 PPT： <ahref="https://1drv.ms/b/s!AqRWJ64OmjGTl0654hq_BwTuh2oR">OneDrive,PDF</a></p><h2 id="年-4月">2019年 4月</h2><p><strong>A brief introduction to x86 OSkernel</strong>，本科操作系统程序设计 演讲</p><p>获取 PPT： <ahref="https://1drv.ms/b/s!AqRWJ64OmjGTrgA1VTP3YYWqCTdR">OneDrive,PDF</a></p><h2 id="年-11月-1">2019年 11月</h2><p><strong>面向规则的软件缺陷检测原型系统 <spanclass="math inline">\(SourStars\)</span></strong>，全国软件与应用学术会议（NASAC2019） 答辩</p><h2 id="年-1月">2020年 1月</h2><p><strong>C++20: C++ at 40</strong>，源伞科技 分享</p><p>获取 PPT： <ahref="https://1drv.ms/b/s!AqRWJ64OmjGTyXbm3ALgMEFKoXJA">OneDrive,PDF</a><span class="math inline">\(^2\)</span></p><h2 id="年-4月-1">2020年 4月</h2><p><strong>C++20: C++ at 40</strong>，信息学院科技创新协会 分享</p><p>获取 PPT： 参考 <span class="math inline">\([2]\)</span></p><h2 id="注意">注意</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><imgsrc="https://licensebuttons.net/l/by-nc-nd/4.0/80x15.png"alt="license-logo" /></a></p><ul><li>所有公开的资料采用 <ahref="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎4.0</a> 国际许可协议进行许可</li><li>直到本文最后更新时，位于中国大陆的访问者可能需要一些特殊的姿势访问OneDrive 分享链接</li><li>封面图出自番剧《佐贺偶像是传奇》</li></ul>]]></content>
      
      
      <categories>
          
          <category> collection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ template </tag>
            
            <tag> STL </tag>
            
            <tag> presentation </tag>
            
            <tag> information </tag>
            
            <tag> haskell </tag>
            
            <tag> functional programming </tag>
            
            <tag> os kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于传统机器学习技术及 AST 分析技术的 Webshell Detector</title>
      <link href="/webshell-detector-based-on-traditional-machine-learning-and-ast-analysis/"/>
      <url>/webshell-detector-based-on-traditional-machine-learning-and-ast-analysis/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="/images/webshell-detector-based-on-traditional-machine-learning-and-ast-analysis/poison-shell-webshell-backdoor.jpg"alt="poison-shell-webshell-backdoor" /><figcaptionaria-hidden="true">poison-shell-webshell-backdoor</figcaption></figure><h2 id="总述">总述</h2><p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST,抽象语法树</a> 上所包含的、可关联到代码特征的构成，可简单抽象分割为</p><ul><li>结构特征</li><li>词频特征</li></ul><p>将相应的特征提取出后，可将已有的样本选用成熟的分类器进行训练：</p><ul><li>结构特征 <span class="math inline">\(\to\)</span> <ahref="https://en.wikipedia.org/wiki/Support_vector_machine">SVM,支持向量机</a></li><li>词频特征 <span class="math inline">\(\to\)</span> <ahref="https://en.wikipedia.org/wiki/Naive_Bayes_classifier">naive Bayesclassifiers, 朴素贝叶斯分类器</a></li></ul><p>一个非常有趣，或说是非常重要的任务，既是从 AST上提取相应的特征，并构造出特征向量，以至直接导入相应分类器进行训练</p><h2 id="ast-结构特征的提取">AST 结构特征的提取</h2><p>因 AST 结构是树状的，我们需要对其进行 “拍平” 操作。 设有一颗 <spanclass="math inline">\(AST\)</span>，其全部 <spanclass="math inline">\(n\)</span> 个节点组成的集合为 <spanclass="math display">\[nodes(AST) = \{node_i | i \in [1,n] \cap\mathbb{N} \}\]</span> 设有节点 <spanclass="math inline">\(node_m,node_n\)</span>，节点 <spanclass="math inline">\(node_m\)</span> 的父节点为 <spanclass="math inline">\(node_n\)</span> 的关系表示为 <spanclass="math display">\[node_n \mathbb{P}_{AST} node_m\quad or\quadnode_m \mathbb{C}_{AST} node_n\]</span> 设有节点 <spanclass="math inline">\(node_i\)</span>， 其子节点组成的集合可表示为 <spanclass="math display">\[children_{AST}(node_i) = \{ node_k | node_k \innodes(AST) \land node_k\mathbb{C}_{AST}node_i \}\]</span>则对于每一个节点 <spanclass="math inline">\(node_i\)</span>，都可以得到一个父子元组 <spanclass="math display">\[self\&amp;children_{AST}(node_i) = (node_i,node_{j1},..., node_{jn})\]</span> 其中 <spanclass="math display">\[node_{j1},...,node_{jn} \inchildren_{AST}(node_i) \land n = |children_{AST}(node_i)|\]</span>故对于这颗 <span class="math inline">\(AST\)</span> 有 <spanclass="math display">\[self\&amp;children_{AST} =\{self\&amp;children_{AST}(node_i) | node_i \in nodes(AST)\}\]</span>对于每一个节点 <spanclass="math inline">\(node_i\)</span>，都有一个整数值 <spanclass="math inline">\(kind\)</span> 可以指代这个节点的类型<spanclass="math inline">\(^1\)</span>，我们表示为 <spanclass="math display">\[kind(node_i)\]</span> 故对于每一个 <spanclass="math inline">\(self\&amp;children_{AST}(node_i)\)</span>都可将其中所有 <span class="math inline">\(node_i\)</span> 替换为 <spanclass="math inline">\(kind(node_i)\)</span> 从而得到一整数集<spanclass="math inline">\(^2\)</span> <spanclass="math display">\[self\&amp;children_{AST}^{kind}(node_i) =(kind(node_1),...,kind(node_n))\]</span> 其中 <spanclass="math display">\[node_1,...,node_n =self\&amp;children_{AST}(node_i)[1],...,self\&amp;children_{AST}(node_i)[n]\]</span>同样的，对于这颗 <span class="math inline">\(AST\)</span> 有 <spanclass="math display">\[self\&amp;children_{AST}^{kind} =\{self\&amp;children_{AST}^{kind}(node_i) | node_i \innodes(AST)\}\]</span> 出于实践上的考量<spanclass="math inline">\(^3\)</span>，对于任意的 <spanclass="math inline">\(self\&amp;children_{AST}^{kind}(node_i)\)</span>，都可取一哈希值作为此元组的代替标记，记为<spanclass="math display">\[hash(self\&amp;children_{AST}^{kind}(node_i))\]</span>则对于这颗 <span class="math inline">\(AST\)</span>，有对于每个 <spanclass="math inline">\(node_i\)</span> 所构成的元组的哈希值 <spanclass="math inline">\(hash(self\&amp;children_{AST}^{kind}(node_i))\)</span>所构成的元组 <span class="math display">\[hash(AST) =(hash(self\&amp;children_{AST}^{kind}(node_1)),...,hash(self\&amp;children_{AST}^{kind}(node_n)))\]</span>其中 <span class="math display">\[node_{1},...,node_{n} \in nodes(AST)\land n = |nodes(AST)|\]</span> 设元组 <spanclass="math inline">\(A\)</span> 中与 <spanclass="math inline">\(a\)</span> 值相同的元素的个数为 <spanclass="math inline">\(i\)</span>，记作 <spanclass="math display">\[count_A(a) = i\]</span> 构建这样一个元组 <spanclass="math inline">\(X\)</span>，使得 <spanclass="math display">\[X[hash(self\&amp;children_{AST}^{kind}(node_i))]=count_{hash(AST)}(hash(self\&amp;children_{AST}^{kind}(node_i)))\]</span>则 <span class="math inline">\(X\)</span> 可作为这颗 <spanclass="math inline">\(AST\)</span> 的特征向量导入 SVM 分类器 设 webshell样本代码的 <span class="math inline">\(AST\)</span> 组成的集合记为 <spanclass="math inline">\(\mathbb{W}\)</span>，则有 <spanclass="math display">\[isWebshell(AST_x) = \begin{cases}0&amp; AST_x \notin \mathbb{W}\\1&amp; AST_x \in \mathbb{W}\end{cases}\]</span> 即对于 <span class="math inline">\(n\)</span> 棵 <spanclass="math inline">\(AST_1,...AST_n\)</span>，有特征矩阵 <spanclass="math inline">\(Xs\)</span> 与期望向量 <spanclass="math inline">\(Y\)</span> <span class="math display">\[\left\{\begin{aligned}Xs &amp; = [ X_{AST_1},...,X_{AST_n} ] \\Ys &amp; = [ isWebshell(AST_1),...,isWebshell(AST_n) ]\end{aligned}\right.\]</span></p><h2 id="ast-词频特征的提取">AST 词频特征的提取</h2><p>在以纯文本的形式分析代码时，由于没有 <ahref="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">Tokenizer,分词器</a>，很难得到有较大意义的“词”，而在 <spanclass="math inline">\(AST\)</span> 层面可以依据 <spanclass="math inline">\(kind\)</span> 值得到有特征意义的“词”<spanclass="math inline">\(^4\)</span> 遍历整颗 <spanclass="math inline">\(AST\)</span>，可得到所有此类的 <spanclass="math inline">\(n\)</span> 个词组成的集合，即 <spanclass="math display">\[words(AST) = \{ word_1, word_2, ..., word_n\}\]</span> 很容易以此利用朴素贝叶斯分类得到预测模型</p><h2 id="附录">附录</h2><p><span class="math inline">\([1]\)</span> 例如，PHP 的 Zend 引擎生成的AST 的结构<ahref="https://github.com/php/php-src/blob/master/Zend/zend_ast.h#L165">如下</a>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> zend_ast_kind; <span class="comment">// L154</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_ast_list</span> &#123;</span> <span class="comment">// L165</span></span><br><span class="line">zend_ast_kind kind;</span><br><span class="line">zend_ast_attr attr;</span><br><span class="line"><span class="type">uint32_t</span> lineno;</span><br><span class="line"><span class="type">uint32_t</span> children;</span><br><span class="line">zend_ast *child[<span class="number">1</span>];</span><br><span class="line">&#125; zend_ast_list;</span><br></pre></td></tr></table></figure> 易看出其中的 <code>zend_ast_kind kind</code>即为节点类型的标记值。</p><p><span class="math inline">\([2]\)</span> 一般在这一步进行对 <spanclass="math inline">\(self\&amp;children_{AST}^{kind}(node_i)\)</span>的“截短”，即使用一些方法降低不同的 <spanclass="math inline">\(self\&amp;children_{AST}^{kind}(node_i)\)</span>的个数，以使得得到的特征向量 <span class="math inline">\(X\)</span>的维度数 <span class="math inline">\(|X|\)</span> 降低。</p><p><span class="math inline">\([3]\)</span> 例如，在大量的 PHP代码样本（超过千万行）中得到的 AST 中，仅有不到 1 万个不同的 <spanclass="math inline">\(self\&amp;children_{AST}^{kind}(node_i)\)</span>的出现频率在 <span class="math inline">\(1/500000\)</span>以上，故得到一个整数（甚至是 <code>16bit</code> 短整数）哈希值是可行的，在实践中，通常采用从 0 开始递增地分配自然数值的简单哈希方法。</p><p><span class="math inline">\([4]\)</span>对于一般的过程式脚本语言，在通俗的概念上，可以认为变量名、常量名、字面量、函数名，或包括面向对象的语言中的类名、接口名、成员名等，都可以称为有特征意义的“词”</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
            <tag> webshell detector </tag>
            
            <tag> machine learning </tag>
            
            <tag> AST </tag>
            
            <tag> program analysis </tag>
            
            <tag> SVM </tag>
            
            <tag> naive bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 如何把字符串字面量的内容映射到类型</title>
      <link href="/how-to-map-string-literal-to-type-in-cpp/"/>
      <url>/how-to-map-string-literal-to-type-in-cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="注意">注意</h2><p><img src="/images/zhihu/zhihu.jpg" alt="zhihu" />本文旨在整理知乎上的回答，原答案链接请<ahref="https://www.zhihu.com/question/268188946/answer/334037634">戳这里</a>。</p><h2id="我觉得我可以写一个趣味小故事了">我觉得我可以写一个趣味小故事了</h2><p>在2013年，Richard Smith提了个提案，<ahref="http://open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3599.html">n3599</a>。</p><p>如果这个提案进了标准，那么将完美地解决题主的问题。</p><p>可惜没有。</p><p>为什么呢，标准委员会以 <em>Revise with additional machinery forcompile time string processing</em> 为由拒绝了这个提案。</p><p>但是很 happy 的是，gcc 和 clang 都支持了这项提案，当然 clang要加一条编译选项 <code>-Wgnu-string-literal-operator-template</code></p><p>所以我先随意写一下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharT, CharT... s&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span> <span class="string">&quot;&quot;</span>_fuck() -&gt; std::integer_sequence&lt;CharT, s...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRLIT_TO_TYPE(strlit) strlit##_fuck</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        std::is_same_v&lt;</span><br><span class="line">            <span class="keyword">decltype</span>(<span class="built_in">STRLIT_TO_TYPE</span>(<span class="string">&quot;abc&quot;</span>)),</span><br><span class="line">            std::integer_sequence&lt;<span class="type">char</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&gt;</span><br><span class="line">        &gt;,</span><br><span class="line">        <span class="string">&quot;Fuck&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ##为什么这么好的feature不能想办法加入标准呢？</p><p>2016 年又有了解决这个问题的新提案，<ahref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf">p0424r0</a>。</p><p>最新版本是 2017 年 11 月的 <ahref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0424r0.pdf">p0424r2</a>。</p><p>写出来的话大概是这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">const</span> <span class="keyword">auto</span>&amp; V&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConstantReference</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp; value = V;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span>&amp; str&gt;</span><br><span class="line"><span class="keyword">constexpr</span> ConstantReference&lt;str&gt; <span class="keyword">operator</span><span class="string">&quot;&quot;</span> _fuck()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Con, std::<span class="type">size_t</span>... Indices&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Fuck</span><span class="params">(Con, std::integer_sequence&lt;std::<span class="type">size_t</span>, Indices...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::integer_sequence&lt;</span><br><span class="line">                std::<span class="type">remove_cv_t</span>&lt;</span><br><span class="line">                    std::<span class="type">remove_extent_t</span>&lt;</span><br><span class="line">                        std::<span class="type">remove_reference_t</span>&lt;</span><br><span class="line">                            <span class="keyword">decltype</span>(Con::value)</span><br><span class="line">                        &gt;</span><br><span class="line">                    &gt;</span><br><span class="line">                &gt;, </span><br><span class="line">                Con::value[Indices]...</span><br><span class="line">            &gt;&#123;&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRLIT_TO_TYPE(strlit)      \</span></span><br><span class="line"><span class="meta">    Fuck(                           \</span></span><br><span class="line"><span class="meta">        strlit##_fuck,              \</span></span><br><span class="line"><span class="meta">        std::make_index_sequence&lt;   \</span></span><br><span class="line"><span class="meta">            std::extent_v&lt;          \</span></span><br><span class="line"><span class="meta">                std::remove_reference_t&lt; \</span></span><br><span class="line"><span class="meta">                    decltype(strlit)\</span></span><br><span class="line"><span class="meta">                &gt;                   \</span></span><br><span class="line"><span class="meta">            &gt;                       \</span></span><br><span class="line"><span class="meta">        &gt;&#123;&#125;                         \</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        std::is_same_v&lt;</span><br><span class="line">            <span class="keyword">decltype</span>(<span class="built_in">STRLIT_TO_TYPE</span>(<span class="string">&quot;abc&quot;</span>)),</span><br><span class="line">            std::integer_sequence&lt;<span class="type">char</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">0</span>&gt;</span><br><span class="line">        &gt;,</span><br><span class="line">        <span class="string">&quot;Fuck&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="section">18.3.5</h2><p>看到 <ahref="https://github.com/boostorg/hana/blob/master/include/boost/hana/string.hpp#L86">hana的实现</a>了 真是令人耳目一新的奇技淫巧 hana 作者太强了</p><h2 id="section-1">18.3.18</h2><p><ahref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r0.pdf">P0732</a>提出了一种更棒的方法，下面直接引用其中给出的例程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharT, std::<span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">basic_fixed_string</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">constexpr</span> <span class="title">basic_fixed_string</span><span class="params">(<span class="type">const</span> CharT (&amp;foo)[N])</span></span></span><br><span class="line"><span class="function">        </span>&#123; std::<span class="built_in">copy</span>(foo, foo+N, m_data); &#125;</span><br><span class="line">        <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> basic_fixed_string &amp;,</span><br><span class="line">                         <span class="type">const</span> basic_fixed_string &amp;) = <span class="keyword">default</span>;</span><br><span class="line">        CharT m_data[N];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> CharT, std::<span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="built_in">basic_fixed_string</span>(<span class="type">const</span> <span class="built_in">CharT</span> (&amp;str)[N])-&gt;basic_fixed_string&lt;CharT, N<span class="number">-1</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N&gt;</span><br><span class="line">    <span class="keyword">using</span> fixed_string = basic_fixed_string&lt;<span class="type">char</span>, N&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> N, std::fixed_string&lt;N&gt; Str&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> hello_A = A&lt;<span class="number">5</span>, <span class="string">&quot;hello&quot;</span>&gt;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ standard </tag>
            
            <tag> c++ template </tag>
            
            <tag> zhihu </tag>
            
            <tag> string literal </tag>
            
            <tag> type </tag>
            
            <tag> meta programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 C++ 顶层 const 和底层 const</title>
      <link href="/top-level-const-and-low-level-const-in-cpp/"/>
      <url>/top-level-const-and-low-level-const-in-cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="注意">注意</h2><p><img src="/images/zhihu/zhihu.jpg" alt="zhihu.jpg" />本文旨在整理知乎上的回答，原答案链接请<ahref="https://www.zhihu.com/question/268569162/answer/339109206">戳这里</a>。</p><h2 id="什么是-top-level-cv-qualifiers">什么是 top-levelcv-qualifiers</h2><p><code>top-level cv-qualifiers</code> 是标准文档中的概念</p><blockquote><p>For a type <strong>cv T</strong>, the <strong>top-levelcv-qualifiers</strong> of that type are those denoted by<strong>cv</strong>.</p></blockquote><h2 id="批判-c-primer">批判 c++ primer</h2><p>但是这个 <code>low-level const</code> 大概是 c++ primer造出来的概念</p><p>我认为这个概念不仅容易让人混淆，而且根本没有存在的必要</p><p>我在网络上寻找到了疑似 c++ primer 中的一个段落</p><blockquote><p>As we’ve seen, a pointer is an object that can point to a differentobject. As a result, we can talk independently about whether a pointeris const and whether the objects to which it can point are const. We usethe term top-level const to indicate that the pointer itself is a const.When a pointer can point to a const object, we refer to that const as alow-level const.</p></blockquote><p>既然 point to a const object 就是 <code>low-level</code> 了，那么point to a pointer that point to a const object 是什么呢？怕不是<code>lower-than-low-level</code> 吧（误</p><h2 id="如何做">如何做</h2><p>那么如何对 c++ 类型系统中的 <code>cv-qualifiers</code>做简单的理解呢？</p><p>我觉得只要理解语义就好了，完全没有必要深究 c++ 继承自 c的拙劣的类型描述文法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Ptr = T *;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Ptr &lt;      <span class="type">int</span>&gt;  a [[maybe_unused]] = <span class="literal">nullptr</span>; <span class="comment">// top-level cv-qualifiers: &#123;const&#125;</span></span><br><span class="line">      Ptr &lt;<span class="type">const</span> <span class="type">int</span>&gt;  b [[maybe_unused]] = <span class="literal">nullptr</span>; <span class="comment">// top-level cv-qualifiers: (empty set)</span></span><br><span class="line"><span class="type">const</span> Ptr &lt;<span class="type">const</span> <span class="type">int</span>&gt;  c [[maybe_unused]] = <span class="literal">nullptr</span>; <span class="comment">// top-level cv-qualifiers: &#123;const&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ standard </tag>
            
            <tag> zhihu </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于解析器组合子的文法解析器的实现</title>
      <link href="/implementation-of-parser-based-on-parser-combinator/"/>
      <url>/implementation-of-parser-based-on-parser-combinator/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="/images/implementation-of-parser-based-on-parser-combinator/chtholly-in-comic.jpg"alt="chtholly-in-comic" /><figcaption aria-hidden="true">chtholly-in-comic</figcaption></figure><h2 id="背景"><em>背景</em></h2><p>　　<em>毫无疑问，形式语言理论在工程实践上取得了巨大的成功。形式文法作为描述形式语言的方法指出了形式语言的确定性。</em></p><p>　　<em>1956年，诺姆·乔姆斯基提出了乔姆斯基谱系，较好地以形式文法表达能力作为因素分出了四个文法层级。其中的上下文无关文法（2-型文法）生成上下文无关语言，为大多数程序设计语言的语法提供了理论基础。</em></p><p>　　<em>上下文无关文法拥有足够强的表达力来表示大多数程序设计语言的语法。实际上，几乎所有程序设计语言都是通过上下文无关文法来定义的。另一方面，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。</em></p><h2 id="理论基础">理论基础</h2><h3 id="ll分析器">LL分析器</h3><p>　　LL分析器是一种处理某些上下文无关文法的自顶向下分析器。它通常被称为是“递归下降”的，这与自底向上的LR分析器的特点“规约上升”相反。它从左到右处理输入，再对句型执行最左推导出语法树。</p><h3 id="组合子逻辑">组合子逻辑</h3><p>　　组合子逻辑是等价于lambda演算的计算模型，可以被看作是lambda演算的变体，它把lambda表达式（用来允许函数抽象）替代为组合子的有限集合，它们是不包含自由变量的原始函数。</p><h3 id="解析器组合子">解析器组合子</h3><p>　　解析器组合子是一个高阶函数，接受几个解析器作为输入，并返回一个新的解析器作为输出。在这种情况下，解析器是一个接受字符串作为输入并返回一些结构作为输出的函数，通常是一个解析树或一组表示解析成功停止的字符串中的位置。</p><p>　　解析器组合子实现了递归下降解析策略，有助于模块化分段构建和测试。这种解析技术被称为组合式解析。使用组合子构建的解析器可以直接构建，可读，模块化，结构良好，易于维护。它们已被广泛用于编译器和处理器的原型。</p><h2 id="目的">目的</h2><p>　　用 C++实现解析器组合子，并在解析器组合子的基础上实现解析器，即实现将符合某个文法的语言代码解析成抽象语法树。</p><h3 id="为什么用-c">为什么用 C++</h3><p>　　在C++11标准（ISO/IEC14882:2011）发布后，现代C++拥有了更强的表达能力，lambda表达式使得函数式写法及高阶函数的表达在C++中实现起来更为容易。C++在类型表达和元编程方面有着一定的优势。本次我选用C++17标准（ISO/IEC14882:2017）实现解析器。</p><h3 id="选用什么文法">选用什么文法</h3><p>　　我以类BNF范式实现了一个简单的语言，在文法上语言更契合LISP的思想：没有语句，只有表达式。但语言并没有使用S表达式，而是使用数学表达式和c-style的风格构建基础表达式。</p><h3 id="怎么构建组合子">怎么构建组合子</h3><p>　　我尝试使用 C++中运算符重载的特性，以简单的语法快速地构建高阶函数，使得组合子在被使用的时候能够贴近于BNF表达式的书写习惯，比如克莱尼星号（*），存在一个或多个（+），推断为A或者B（A|B），推断为AB(A,B)，可选推断（~） 等等。</p><h2 id="总体设计">总体设计</h2><figure><imgsrc="/images/implementation-of-parser-based-on-parser-combinator/design-show.png"alt="design-show" /><figcaption aria-hidden="true">design-show</figcaption></figure><h2 id="具体实现">具体实现</h2><figure><imgsrc="/images/implementation-of-parser-based-on-parser-combinator/impl-show.png"alt="impl-show" /><figcaption aria-hidden="true">impl-show</figcaption></figure><h3 id="basictree-泛型树"><code>BasicTree</code> 泛型树</h3><p>　　泛型树旨在构建一颗接受泛型元素的树状图结构。其中每颗子树的子节点的数量是不被限制，且是动态确定的。且每颗子树都知道其父节点的信息，即可以在任意时刻轻易地回溯。</p><p>　　遍历或修改树中的元素以内置类 <code>Visitor</code> 或<code>Modifier</code> 完成。</p><p>　　<code>Visitor</code>表示了正在对某个节点进行访问，提供了访问父节点，上/下一个兄弟节点或者上/下一个子节点的方法。但<code>Visitor</code> 不具备增加/删除节点的能力。</p><p>　　<code>Modifier</code> 是 <code>Visitor</code>的一个子类（即其共有继承了<code>Visitor</code>），所以其拥有<code>Visitor</code>的全部功能，且<code>Modifier</code>提供了对树的结构的修改操作，包括增加/删除节点，交换节点或是移动节点。</p><h3 id="basicparseunit-泛型语法单元"><code>BasicParseUnit</code>泛型语法单元</h3><p>　　泛型语法单元旨在表示一个终结符或非终结符，它携带了一个终结符或非终结符的全部信息。</p><h3 id="basicparsetree-泛型语法树"><code>BasicParseTree</code>泛型语法树</h3><p>　　泛型语法树是泛型树对于泛型语法单元的特化。</p><h3id="basicparsercombinator-泛型解析器组合子"><code>BasicParserCombinator</code>泛型解析器组合子</h3><p>　　泛型解析器组合子用于生成解析器，其由一系列高阶函数作为静态方法，接受特定类型的函数，返回特定类型的函数，即解析器组合子进行的是对函数的处理，将一系列函数以不同的语义进行不同的组合操作，以实现文法的构建。</p><p>　　其内嵌类 <code>Process</code> 是对某个函数的封装，并增加了<code>isOptional</code> 属性，每个 <code>Process</code> 都是对某个接受<code>Info</code> 类型对象且返回 <code>Info</code>类型对象的函数的封装。每个 <code>Info</code>类型都携带目前被处理的代码的 View 信息和语法树上对于目前的某个节点的<code>Modifier</code> 信息。</p><p>　　解析器组合子的大多数静态方法或是对操作符重载的友元函数都接受一或多个<code>Process</code> 对象而后返回一个新的 <code>Process</code>对象。这个新的<code>Process</code>对象就是一条被结合出的新的文法产生式。</p><h3 id="basicparser-泛型解析器"><code>BasicParser</code> 泛型解析器</h3><p>　　泛型解析器是对泛型解析器组合子的应用。在语义上讲，其继承了泛型解析器组合子。需要注意的是解析器在实现上大量使用了C++17的<code>inline variable</code>，以更清晰地写出文法规则。解析器使用组合子生成所有的产生式（文法规则），以体现组合子在实际应用和写法上的优势。</p><h2 id="关键问题及其解决方法">关键问题及其解决方法：</h2><h3id="为什么使用泛型泛型是否是过度设计">为什么使用泛型，泛型是否是过度设计？</h3><p>　　使用泛型是为了根据被处理的语言代码的编码不同进行不同的处理，即选择不同的<code>StringView</code>进行处理。由于已经对于所有的泛型解析器/组合子特化了模板参数为<code>std::string_view</code>的类型，所以实际上没有增加使用难度，也没有对表层API进行任何更改。</p><h3id="为什么混合处理词法解析和文法解析">为什么混合处理词法解析和文法解析？</h3><p>　　因为本身词法就可以看作文法的一部分，词法和文法区别表现在工程上，即表现在语法树的构建和（大部分语言中）空白字符的处理上。通过某些写法，我用组合子以同一范式写出了词法和文法的产生式，并处理了词法的贪心匹配需求。</p><h2 id="总结">总结：</h2><p>　　虽然解析器组合子对于递归下降的解析没有做出任何的复杂度改善和优化（即在自顶向下解析中，当解析模棱两可的上下文无关语法时，组合式分析需要指数级的时间和空间复杂度），但解析器组合子大幅度改善了硬编码的文法解析实现的写法，使得使用组合器构建的解析器有着易于构建，可读，模块化，结构合理，易于维护的特点。</p><p>　　本项目的解析器组合子并没有做到自动消除左递归，即在处理左递归产生式时，解析器永远不会被终止。但可以了解到的是，Frost和Hafiz在2006年描述了一种识别算法，该算法可以接受具有直接左递归规则的歧义语法，并且在2007年该算法被扩展为一个完整的分析算法，以适应间接以及多项式级时间复杂度的直接左递归，并用Haskell实现了该算法。同样的，早在1996年，Frost和Szydlowski就展示了解析器组合子如何使用记忆化来使时间复杂度减少到多项式级。</p><h2 id="附录">附录：</h2><ol type="1"><li>本项目的Git仓库（HTTPS方式）：<ul><li>https://github.com/PragmaTwice/ChthollyLang</li></ul></li><li>本项目使用Apache License 2.0：<ul><li>http://www.apache.org/licenses/LICENSE-2.0</li></ul></li><li>参见：<ul><li>https://en.wikipedia.org/wiki/Combinatory_logic</li><li>https://en.wikipedia.org/wiki/Context-free_grammar</li><li>https://en.wikipedia.org/wiki/Parsing_expression_grammar</li><li>https://en.wikipedia.org/wiki/LL_parser</li><li>https://en.wikipedia.org/wiki/Parser_combinator</li></ul></li><li>封面图系番剧《末日时在做什么？有没有空？可以来拯救吗？》，作者不详</li></ol>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> parser </tag>
            
            <tag> parser combinator </tag>
            
            <tag> implementation </tag>
            
            <tag> chtholly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 自己写一个更好的 string 需要什么步骤</title>
      <link href="/how-to-write-a-better-string-in-cpp/"/>
      <url>/how-to-write-a-better-string-in-cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="注意">注意</h2><p><img src="/images/zhihu/zhihu.jpg" alt="zhihu" />本文旨在整理知乎上的回答，原答案链接请<ahref="https://www.zhihu.com/question/64949799/answer/228337291">戳这里</a>。</p><h2 id="对-stdbasic_string-的理解">对 std::basic_string 的理解</h2><p><code>std::string</code> 的设计思想和 STL 以及整个 Std Librarys是一致的，不以运行效率为代价做任何易用性上的改变，对于一些非常复杂或者没有统一方案的东西宁可不加入，保持整体上的洁净。</p><p><a href="https://en.cppreference.com/w/">CppRef</a> 上这样描述<code>std::basic_string</code> :</p><blockquote><p>The class is dependent neither on the character type nor on thenature of operations on that type.</p></blockquote><p>但是这样的结果是大家都以其他语言的 string 去喷<code>std::string</code>，就是因为都起了相同的名字——叫 string。</p><h2 id="安利-text_view">安利 text_view</h2><p>那么大家心目中的 string 在 c++ 里是怎么样的呢 ， <ahref="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0244r2.html"><code>text_view</code></a>提案里这样说的：</p><blockquote><p>C++11 added support for new character types [N2249] and Unicodestring literals [N2442], but neither C++11, nor more recent standardshave provided means of efficiently and conveniently enumerating codepoints in Unicode or legacy encodings. While it is possible to implementsuch enumeration using interfaces provided in the standard <locale> and<codecvt> libraries, doing so is awkward, requires that text be providedas pointers to contiguous memory, and inefficent due to virtual functioncall overhead.</p></blockquote><p><code>text_view</code> 是怎么样的呢：</p><blockquote><p>(text_view) provides iterator and range based interfaces for encodingand decoding strings in a variety of character encodings. The interfaceis intended to support all modern and legacy character encodings, thoughimplementations are expected to only provide support for a limited setof encodings.</p></blockquote><blockquote><p>(text_view) intended to solve the above (shortage in processingstrings with <codecvt>) issues while also providing a modern interfacethat is intuitive to use and can be used with other standard providedfacilities; in particular, the C++ standard <algorithm> library.</p></blockquote><p>那么要在C++中写一个“更好的“的 string ，应该就是写一个切合大家心中对string 的所有易用性上的幻想的 string，大概可以参考 <ahref="https://github.com/tahonermann/text_view"><code>text_view</code>提案附带的实现</a>，以及 <a href="http://doc.qt.io/qt-5/qstring.html">Qt/ <code>QString</code></a> , 既然要易用，配套个正则也是加分项吧（</p>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> zhihu </tag>
            
            <tag> string </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
